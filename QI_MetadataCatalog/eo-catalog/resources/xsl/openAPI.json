{
  "openapi": "3.0.0",
  "info": {
    "description": "FedEO provides interoperable access, following ISO/OGC interface guidelines, to Earth Observation metadata.\nYou can try all HTTP operations described in this OpenAPI 3.0 specification.",
    "title": "FedEO Earth Observation Catalog",
    "contact": {
      "name": "Spacebel s.a.",
      "url": "http://www.spacebel.be",
      "email": "yves.coene@spacebel.be"
    },
    "version": "1.0.0",
    "license": {
      "name": "Apache 2.0",
      "url": "http://www.apache.org/licenses/LICENSE-2.0.html"
    },
    "x-origin": [
      {
        "converter": {
          "url": "https://github.com/lucybot/api-spec-converter",
          "version": "2.0.1"
        },
        "format": "OpenSearch Description Document",
        "url": "SERVER_URL/description"
      }
    ],
    "x-providerName": "Copyright 2017-2018, European Space Agency.",
    "x-serviceName": "FedEO"
  },
  "servers": [
    {
      "url": "SERVER_URL"
    }
  ],
  "x-queries": {
    "example": [
      {
        "eo:parentIdentifier": "TropForest",
        "time:end": "2009-04-10T00:00:00Z",
        "time:start": "2009-04-01T00:00:00Z"
      }
    ]
  },
  "x-@context": {
    "dc": "http://purl.org/dc/elements/1.1/",
    "eo": "http://a9.com/-/opensearch/extensions/eo/1.0/",
    "geo": "http://a9.com/-/opensearch/extensions/geo/1.0/",
    "os": "http://a9.com/-/spec/opensearch/1.1/",
    "semantic": "http://a9.com/-/opensearch/extensions/semantic/1.0/",
    "sru": "http://a9.com/-/opensearch/extensions/sru/2.0/",
    "time": "http://a9.com/-/opensearch/extensions/time/1.0/"
  },
  "tags": [
    {
      "name": "LandingPage",
      "description": "Provide Landing page of the catalog."
    },
    {
      "name": "Conformance",
      "description": "Provide conformance class information."
    },
    {
      "name": "APIDefinition",
      "description": "Describe the catalogue interface."
    },
    {
      "name": "Collections",
      "description": "Metadata about the resource collections."
    },
    {
      "name": "Datasets",
      "description": "Operations for Datasets."
    },
    {
      "name": "Dataset",
      "description": "Operations for a Datasets"
    },
    {
      "name": "ProductInformation",
      "description": "Operations for a ProductInformation."
    },
    {
      "name": "QualityInformation",
      "description": "Operations for a QualityInformation."
    },
    {
      "name": "QualityIndicators",
      "description": "Operations for qualityIndicators."
    },
    {
      "name": "Metric",
      "description": "Operations for a qualityIndicator."
    }
  ],
  "paths": {
    "/": {
      "get": {
        "tags": [
          "LandingPage"
        ],
        "summary": "provide landing page (rel=\"self\") in OAPI Common format",
        "description": "Get Landing Page.",
        "responses": {
          "200": {
            "description": "Landing Page is successfully returned",
            "content": {
              "application/json": {
                "schema": {},
                "example": {
                  "links": [
                    {
                      "rel": "self",
                      "href": "SERVER_URL",
                      "type": "application/json",
                      "title": "this document"
                    },
                    {
                      "rel": "service",
                      "href": "SERVER_URL/description",
                      "type": "application/openapi+json;version=3.0",
                      "title": "the OpenAPI definition"
                    },
                    {
                      "rel": "service",
                      "href": "SERVER_URL/description",
                      "type": "application/opensearchdescription+xml",
                      "title": "the OpenSearch Description Document"
                    },
                    {
                      "rel": "conformance",
                      "href": "SERVER_URL/conformance",
                      "type": "application/json",
                      "title": "OGC conformance classes implemented by this API"
                    },
                    {
                      "rel": "data",
                      "href": "SERVER_URL/resources",
                      "type": "application/json",
                      "title": "Services and series metadata"
                    }
                  ]
                }
              }
            }
          },
          "500": {
            "description": "Unexpected error"
          }
        }
      }
    },
    "/conformance": {
      "get": {
        "tags": [
          "Conformance"
        ],
        "summary": "provide conformance class information (rel=\"conformance\") in OAPI Common format",
        "description": "Get conformance class information.",
        "responses": {
          "200": {
            "description": "conformance class information is successfully returned",
            "content": {
              "application/json": {
                "schema": {},
                "example": {
                  "conformsTo": [
                    "http://www.opengis.net/spec/eopad-geojson/1.0/req/core",
                    "http://www.opengis.net/spec/os-geojson/1.0/req/core",
                    "http://www.opengis.net/spec/owc-geojson/1.0/req/core"
                  ]
                }
              }
            }
          },
          "500": {
            "description": "Unexpected error"
          }
        }
      }
    },
    "/collections": {
      "get": {
        "tags": [
          "Collections"
        ],
        "summary": "Metadata about the resource collections",
        "description": "Metadata about the resource collections.",
        "responses": {
          "200": {
            "description": "metadata about the resource collections is successfully returned",
            "content": {
              "application/json": {
                "schema": {},
                "example": {
                  "collections": [
                    {
                      "description": "All metadata records.",
                      "links": [
                        {
                          "rel": "items",
                          "href": "SERVER_URL/resources",
                          "type": "application/geo+json",
                          "title": "Resources"
                        }
                      ],
                      "id": "resources",
                      "title": "Resources"
                    },
                    {
                      "description": "Metadata records representing EO services and applications.",
                      "links": [
                        {
                          "rel": "items",
                          "href": "SERVER_URL/resources?type=service",
                          "type": "application/geo+json",
                          "title": "Services and applications"
                        }
                      ],
                      "id": "services",
                      "title": "EO services and applications"
                    },
                    {
                      "description": "Metadata records representing EO series (a.k.a. EO collections).",
                      "links": [
                        {
                          "rel": "items",
                          "href": "SERVER_URL/resources?type=collection",
                          "type": "application/geo+json",
                          "title": "Series"
                        }
                      ],
                      "id": "series",
                      "title": "EO Series"
                    }
                  ],
                  "links": [
                    {
                      "rel": "self",
                      "href": "SERVER_URL/collections",
                      "type": "application/json",
                      "title": "this document"
                    }
                  ]
                }
              }
            }
          },
          "500": {
            "description": "Unexpected error"
          }
        }
      }
    },
    "/collections/{collectionId}": {
      "get": {
        "tags": [
          "Collections"
        ],
        "summary": "Metadata about a resource collection",
        "description": "Metadata about a resource collection.",
        "parameters": [
          {
            "name": "collectionId",
            "in": "path",
            "x-value": "{geo:uid}",
            "required": true,
            "description": "Collection identifier.",
            "schema": {
              "type": "string",
              "default": "resources",
              "enum": [
                "resources",
                "services",
                "series"
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "description": "metadata about a resource collection is successfully returned",
            "content": {
              "application/json": {
                "schema": {},
                "example": {
                  "description": "Metadata records representing EO services and applications.",
                  "links": [
                    {
                      "rel": "items",
                      "href": "SERVER_URL/resources?type=service",
                      "type": "application/geo+json",
                      "title": "Services and applications"
                    }
                  ],
                  "id": "services",
                  "title": "EO services and applications"
                }
              }
            }
          },
          "500": {
            "description": "Unexpected error"
          }
        }
      }
    },
    "/description": {
      "get": {
        "tags": [
          "APIDefinition"
        ],
        "summary": "Describe the catalogue interface (rel=\"service\")",
        "description": "Get catalogue interface description.",
        "parameters": [
          {
            "name": "httpAccept",
            "in": "query",
            "description": "Query parameter to define expected reponse type.",
            "required": false,
            "schema": {
              "type": "string",
              "default": "application/openapi+json;version=3.0",
              "enum": [
                "application/opensearchdescription+xml",
                "application/openapi+json;version=3.0"
              ]
            }
          }
        ],
        "operationId": "Describe",
        "responses": {
          "200": {
            "description": "OSDD is successfully returned",
            "content": {
              "application/opensearchdescription+xml": {},
              "application/openapi+json;version=3.0": {}
            }
          },
          "400": {
            "description": "Bad request."
          },
          "500": {
            "description": "Unexpected error"
          }
        }
      }
    },
    "/series/{seriesId}/description": {
      "get": {
        "tags": [
          "APIDefinition"
        ],
        "description": "Get OSDD of a series.",
        "parameters": [
          {
            "name": "seriesId",
            "in": "path",
            "x-value": "{eo:parentIdentifier}",
            "required": true,
            "description": "Series identifier.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "201": {
            "description": "OSDD is successfully returned"
          },
          "400": {
            "description": "Bad request."
          },
          "500": {
            "description": "Unexpected error"
          }
        }
      }
    },
    "/series/{seriesId}/datasets": {
      "post": {
        "tags": [
          "Datasets"
        ],
        "description": "Insert a new dataset to the catalogue.",
        "operationId": "Insert",
        "parameters": [
          {
            "name": "seriesId",
            "in": "path",
            "x-value": "{eo:parentIdentifier}",
            "required": true,
            "description": "Series identifier.",
            "schema": {
              "type": "string"
            }
          }
        ],
		"security": [{"BasicAuth": []}],
        "requestBody": {
          "description": "Insert a new dataset to the catalogue.",
          "required": true,
          "content": {
            "application/geo+json": {
              "schema": {
                "$ref": "#/components/schemas/Feature"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Dataset has been successfully inserted"
          },
          "400": {
            "description": "Bad request."
          },
          "415": {
            "description": "Unsupported Media Type."
          },
          "500": {
            "description": "Unexpected error"
          }
        }
      },
      "delete": {
        "tags": [
          "Datasets"
        ],
        "description": "Delete all datasets of a dataset series.",
        "parameters": [
          {
            "name": "seriesId",
            "in": "path",
            "x-value": "{eo:parentIdentifier}",
            "required": true,
            "description": "Series identifier.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Dataset has been deleted."
          },
          "401": {
            "description": "Unauthorized."
          },
          "500": {
            "description": "Unexpected error"
          }
        }
      },
      "get": {
        "tags": [
          "Datasets"
        ],
        "summary": "Dataset search (rel=\"results\")",
        "description": "The endpoint returns information about the *FedEO* dataset matching specific filtering criteria such as organisation, platform, instrument, title, keyword and lists the datasets .\n",
        "parameters": [
          {
            "name": "seriesId",
            "in": "path",
            "x-value": "{eo:parentIdentifier}",
            "required": true,
            "description": "The id of the dataset series to retrieve dataset",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "httpAccept",
            "in": "query",
            "description": "Query parameter to define expected reponse type.",
            "required": false,
            "schema": {
              "type": "string",
              "default": "application/geo+json",
              "enum": [
                "application/geo+json"
              ]
            }
          },
          {
            "name": "maximumRecords",
            "in": "query",
            "x-value": "{count}",
            "description": "Number of records {os:count}.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 10,
              "minimum": 0,
              "exclusiveMinimum": false,
              "maximum": 50,
              "exclusiveMaximum": false
            }
          },
          {
            "name": "startRecord",
            "in": "query",
            "x-value": "{startIndex}",
            "description": "Start index of first result {os:startIndex}.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 1,
              "minimum": 1
            }
          },
          {
            "name": "startPage",
            "in": "query",
            "x-value": "{startPage}",
            "description": "Start index of first result page {os:startPage}.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32",
              "minimum": 1
            }
          },
          {
            "name": "query",
            "in": "query",
            "x-value": "{searchTerms}",
            "description": "Free text search term {os:searchTerms}.",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "startDate",
            "in": "query",
            "x-value": "{time:start}",
            "description": "Start datetime of temporal constraint {time:start}.",
            "required": false,
            "allowEmptyValue": true,
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          },
          {
            "name": "endDate",
            "in": "query",
            "x-value": "{time:end}",
            "description": "End datetime of temporal constraint {time:end}.",
            "required": false,
            "allowEmptyValue": true,
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          },
          {
            "name": "bbox",
            "in": "query",
            "x-value": "{geo:box}",
            "description": "Area of interest {geo:box}.",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "lat",
            "in": "query",
            "x-value": "{geo:lat}",
            "description": "Latitude of center of area of interest {geo:lat}.",
            "required": false,
            "schema": {
              "type": "number",
              "format": "double",
              "minimum": -90,
              "exclusiveMinimum": false,
              "maximum": 90,
              "exclusiveMaximum": false
            }
          },
          {
            "name": "lon",
            "in": "query",
            "x-value": "{geo:lon}",
            "description": "Longitude of center of area of interest {geo:lon}.",
            "required": false,
            "schema": {
              "type": "number",
              "format": "double",
              "minimum": -180,
              "exclusiveMinimum": false,
              "maximum": 180,
              "exclusiveMaximum": false
            }
          },
          {
            "name": "name",
            "in": "query",
            "x-value": "{geo:name}",
            "description": "Name of area of interest {geo:name}.",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "radius",
            "in": "query",
            "x-value": "{geo:radius}",
            "description": "Radius of area of interest {geo:radius} in meters.  Is combined with {geo:lon} and {geo:lat} or {geo:name}.",
            "required": false,
            "schema": {
              "type": "number",
              "format": "double",
              "minimum": 0,
              "exclusiveMinimum": false,
              "default": 100000
            }
          },
          {
            "name": "geometry",
            "in": "query",
            "x-value": "{geo:geometry}",
            "description": "Area of interest in WKT format {geo:geometry}.",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "uid",
            "in": "query",
            "x-value": "{geo:uid}",
            "description": "Local identifier {geo:uid} of the dataset series returned as \\<dc:identifier\\> in response.",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "platform",
            "in": "query",
            "x-value": "{eo:platform}",
            "description": "Satellite name {eo:platform}.",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "platformSerialIdentifier",
            "in": "query",
            "x-value": "{eo:platformSerialIdentifier}",
            "description": "Satellite serial identifier {eo:platformSerialIdentifier}.",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "instrument",
            "in": "query",
            "x-value": "{eo:instrument}",
            "description": "Instrument name {eo:instrument}.",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "sensorType",
            "in": "query",
            "x-value": "{eo:sensorType}",
            "description": "Sensor type {eo:sensorType}.",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "resolution",
            "in": "query",
            "x-value": "{eo:resolution}",
            "description": "Sensor resolution {eo:resolution}.",
            "required": false,
            "schema": {
              "type": "number",
              "format": "double"
            }
          },
          {
            "name": "creationDate",
            "in": "query",
            "x-value": "{eo:creationDate}",
            "description": "Creation date of the datasets {eo:creationDate}.",
            "required": false,
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          },
          {
            "name": "modificationDate",
            "in": "query",
            "x-value": "{eo:modificationDate}",
            "description": "Modification date of the datasets {eo:modificationDate}.",
            "required": false,
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          },
          {
            "name": "productionStatus",
            "in": "query",
            "x-value": "{eo:productionStatus}",
            "description": "Status of the datasets {eo:productionStatus}.",
            "required": false,
            "schema": {
              "type": "string",
              "enum": [
                "ARCHIVED",
                "ACQUIRED",
                "CANCELLED"
              ]
            }
          },
          {
            "name": "acquisitionType",
            "in": "query",
            "x-value": "{eo:acquisitionType}",
            "description": "AcquisitionType of the datasets {eo:acquisitionType}.",
            "required": false,
            "schema": {
              "type": "string",
              "enum": [
                "NOMINAL",
                "CALIBRATION",
                "OTHER"
              ]
            }
          },
          {
            "name": "orbitNumber",
            "in": "query",
            "x-value": "{eo:orbitNumber}",
            "description": "Orbit number {eo:orbitNumber}.",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "orbitDirection",
            "in": "query",
            "x-value": "{eo:orbitDirection}",
            "description": "Orbit direction{eo:orbitDirection}.",
            "required": false,
            "schema": {
              "type": "string",
              "enum": [
                "ASCENDING",
                "DESCENDING"
              ]
            }
          },
          {
            "name": "track",
            "in": "query",
            "x-value": "{eo:track}",
            "description": "Track {eo:track}.",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "frame",
            "in": "query",
            "x-value": "{eo:frame}",
            "description": "Frame {eo:frame}.",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "swathIdentifier",
            "in": "query",
            "x-value": "{eo:swathIdentifier}",
            "description": "Swath identifier {eo:swathIdentifier}.",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "lowestLocation",
            "in": "query",
            "x-value": "{eo:lowestLocation}",
            "description": "Lowest location {eo:lowestLocation}.",
            "required": false,
            "schema": {
              "type": "number",
              "format": "double"
            }
          },
          {
            "name": "highestLocation",
            "in": "query",
            "x-value": "{eo:highestLocation}",
            "description": "Highest location {eo:highestLocation}.",
            "required": false,
            "schema": {
              "type": "number",
              "format": "double"
            }
          },
          {
            "name": "productVersion",
            "in": "query",
            "x-value": "{eo:productVersion}",
            "description": "Product version {eo:productVersion}.",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "productQualityStatus",
            "in": "query",
            "x-value": "{eo:productQualityStatus}",
            "description": "Product quality status {eo:productQualityStatus}.",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "productQualityDegradationTag",
            "in": "query",
            "x-value": "{eo:productQualityDegradationTag}",
            "description": "Product quality degradation tag {eo:productQualityDegradationTag}.",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "processorName",
            "in": "query",
            "x-value": "{eo:processorName}",
            "description": "Processor mame {eo:processorName}.",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "processingCenter",
            "in": "query",
            "x-value": "{eo:processingCenter}",
            "description": "Processing center {eo:processingCenter}.",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "processingDate",
            "in": "query",
            "x-value": "{eo:processingDate}",
            "description": "Processing date {eo:processingDate}.",
            "required": false,
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          },
          {
            "name": "sensorMode",
            "in": "query",
            "x-value": "{eo:sensorMode}",
            "description": "Sensor mode {eo:sensorMode}.",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "archivingCenter",
            "in": "query",
            "x-value": "{eo:archivingCenter}",
            "description": "Archiving center {eo:archivingCenter}.",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "processingMode",
            "in": "query",
            "x-value": "{eo:processingMode}",
            "description": "Processing mode {eo:processingMode}.",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "acquisitionStation",
            "in": "query",
            "x-value": "{eo:acquisitionStation}",
            "description": "Acquisition station {eo:acquisitionStation}.",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "acquisitionSubType",
            "in": "query",
            "x-value": "{eo:acquisitionSubType}",
            "description": "Acquisition sub type {eo:acquisitionSubType}.",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "startTimeFromAscendingNode",
            "in": "query",
            "x-value": "{eo:startTimeFromAscendingNode}",
            "description": "Start time from ascending node {eo:startTimeFromAscendingNode}.",
            "required": false,
            "schema": {
              "type": "number",
              "format": "double"
            }
          },
          {
            "name": "completionTimeFromAscendingNode",
            "in": "query",
            "x-value": "{eo:completionTimeFromAscendingNode}",
            "description": "Completion time from ascending node {eo:completionTimeFromAscendingNode}.",
            "required": false,
            "schema": {
              "type": "number",
              "format": "double"
            }
          },
          {
            "name": "illuminationAzimuthAngle",
            "in": "query",
            "x-value": "{eo:illuminationAzimuthAngle}",
            "description": "Illumination azimuth angle {eo:illuminationAzimuthAngle}.",
            "required": false,
            "schema": {
              "type": "number",
              "format": "double"
            }
          },
          {
            "name": "illuminationZenithAngle",
            "in": "query",
            "x-value": "{eo:illuminationZenithAngle}",
            "description": "Illumination zenit angle {eo:illuminationZenithAngle}.",
            "required": false,
            "schema": {
              "type": "number",
              "format": "double"
            }
          },
          {
            "name": "illuminationElevationAngle",
            "in": "query",
            "x-value": "{eo:illuminationElevationAngle}",
            "description": "Illumination elevation angle {eo:illuminationElevationAngle}.",
            "required": false,
            "schema": {
              "type": "number",
              "format": "double"
            }
          },
          {
            "name": "productType",
            "in": "query",
            "x-value": "{eo:productType}",
            "description": "Product Type {eo:productType}.",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "processingLevel",
            "in": "query",
            "x-value": "{eo:processingLevel}",
            "description": "Processing level {eo:processingLevel}.",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "specificationTitle",
            "in": "query",
            "x-value": "{eo:specificationTitle}",
            "description": "Specification title {eo:specificationTitle}.",
            "required": false,
            "schema": {
              "type": "string",
              "enum": [
               "degradedDataPercentageMetric", 
               "degradedAncillaryDataPercentageMetric",
               "formatCorrectnessMetric",
               "generalQualityMetric" ,
               "geometricQualityMetric",
               "radiometricQualityMetric",
               "sensorQualityMetric",
                "feasibilityControlMetric",
                "deliveryControlMetric",
                "ordinaryControlMetric",
                "detailedControlMetric",
                "harmonizationControlMetric",
                "ipForLpInformationMetric",
                "lpInterpretationMetric",
                "lpMetadataControlMetric",
                "lpOrdinaryControlMetric",
                "lpThematicValidationMetric"
              ]
            }
          },
          {
            "name": "degree",
            "in": "query",
            "x-value": "{eo:degree}",
            "description": "Degree {eo:degree}.",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "An array of dataset series",
            "content": {
              "application/geo+json": {
                "schema": {
                  "$ref": "#/components/schemas/FeatureCollection"
                },
                "example": {
                  "features": [
                    {
                      "geometry": {
                        "coordinates": [
                          [
                            [
                              14.186107522713066,
                              50.14002219508509
                            ],
                            [
                              14.348557265087889,
                              50.190863360699744
                            ],
                            [
                              14.52707194102769,
                              50.22238131434859
                            ],
                            [
                              14.70471208561416,
                              50.15631934376189
                            ],
                            [
                              14.762121752264225,
                              50.11661835893974
                            ],
                            [
                              14.776263231679243,
                              50.08705944886458
                            ],
                            [
                              14.759382059466128,
                              50.04888224005577
                            ],
                            [
                              14.736099726431998,
                              50.035462644701234
                            ],
                            [
                              14.725798743272927,
                              49.98844155508602
                            ],
                            [
                              14.673311418036075,
                              49.95524536878365
                            ],
                            [
                              14.567718909876344,
                              49.963098371814596
                            ],
                            [
                              14.393611244433437,
                              49.89671406657247
                            ],
                            [
                              14.300307718430275,
                              49.9106994061699
                            ],
                            [
                              14.262366285871089,
                              49.939623961782445
                            ],
                            [
                              14.257705254305824,
                              49.96457124584049
                            ],
                            [
                              14.187100684005998,
                              50.036319364709136
                            ],
                            [
                              14.157501941761778,
                              50.09104091038224
                            ],
                            [
                              14.161937344554374,
                              50.12127156190347
                            ],
                            [
                              14.186107522713066,
                              50.14002219508509
                            ]
                          ]
                        ],
                        "type": "Polygon"
                      },
                      "id": "SERVER_URL/series/EOP:ESA:LP:UC1/datasets/IMD_2018_010m",
                      "type": "Feature",
                      "properties": {
                        "date": "2020-06-17T16:27:10.01Z",
                        "identifier": "IMD_2018_010m",
                        "kind": "http://purl.org/dc/dcmitype/Dataset",
                        "parentIdentifier": "EOP:ESA:LP:UC1",
                        "productInformation": {
                          "referenceSystemIdentifier": "http://www.opengis.net/def/crs/EPSG/0/3035",
                          "qualityInformation": {
                            "qualityIndicators": [
                              {
                                "lineage": "http://qcmms.esa.int/Mx_vpx_v0.9",
                                "isMeasurementOf": "http://qcmms.esa.int/quality-indicators/#ipForLpInformationMetric",
                                "vpxCoverage": {
                                  "2018": {
                                    "min": 0,
                                    "max": 1,
                                    "gapPct": 7,
                                    "mask": "http://93.91.57.111/UC1/image_products/vpx_coverage_10m.jpg"
                                  }
                                },
                                "generatedAtTime": "2020-06-17T16:27:09.98Z",
                                "value": true,
                                "fitnessForPurpose": "PARTIAL"
                              },
                              {
                                "lineage": "http://qcmms.esa.int/QCMMS_QCManager_v1.0",
                                "isMeasurementOf": "http://qcmms.esa.int/quality-indicators/#lpInterpretationMetric",
                                "densityCover": {
                                  "mae": 10.25,
                                  "lineage": "http://qcmms.esa.int/Mx_sealing_simple_v0.9",
                                  "rmse": 13.22,
                                  "pearsonR": 0.69,
                                  "mse": 174.86
                                },
                                "generatedAtTime": "2020-06-17T16:27:20.58Z",
                                "classification": {
                                  "lineage": "http://qcmms.esa.int/Mx_sealing_simple_v0.9",
                                  "producersAccuracy": 99,
                                  "usersAccuracy": 92,
                                  "confusionMatrix": [
                                    [
                                      92,
                                      8
                                    ],
                                    [
                                      1,
                                      99
                                    ]
                                  ],
                                  "kappa": 88,
                                  "codingClasses": [
                                    "non-urban",
                                    "urban"
                                  ],
                                  "overallAccuracy": 91
                                },
                                "value": true
                              },
                              {
                                "lineage": "http://qcmms.esa.int/QCMMS_QCManager_v1.0",
                                "metadataCompliancy": true,
                                "isMeasurementOf": "http://qcmms.esa.int/quality-indicators/#lpMetadataControlMetric",
                                "metadataAvailable": true,
                                "metadataSpecification": "INSPIRE",
                                "generatedAtTime": "2020-06-17T16:27:20.59Z",
                                "value": true
                              },
                              {
                                "epsg": "3035",
                                "lineage": "http://qcmms.esa.int/QCMMS_QCManager_v1.0",
                                "rasterFormat": "GeoTIFF",
                                "isMeasurementOf": "http://qcmms.esa.int/quality-indicators/#lpOrdinaryControlMetric",
                                "read": true,
                                "dataType": "u8",
                                "generatedAtTime": "2020-06-17T16:27:20.59Z",
                                "extentUlLr": [
                                  4621500,
                                  3019160,
                                  4659740,
                                  2988580
                                ],
                                "value": true,
                                "xRes": 10,
                                "yRes": 10,
                                "aoiCoveragePct": 100
                              },
                              {
                                "lineage": "http://qcmms.esa.int/QCMMS_QCManager_v1.0",
                                "isMeasurementOf": "http://qcmms.esa.int/quality-indicators/#lpThematicValidationMetric",
                                "densityCover": {
                                  "mae": 10.2,
                                  "lineage": "http://qcmms.esa.int/prague_sealing_references_330.shp",
                                  "codingValues": {
                                    "unclassified": 254,
                                    "sealingMax": 100,
                                    "sealingMin": 1,
                                    "outsideAoi": 254,
                                    "non-sealing": 0
                                  },
                                  "rmse": 11,
                                  "pearsonR": 0.71,
                                  "mse": 120.3
                                },
                                "generatedAtTime": "2020-06-17T16:27:20.59Z",
                                "classification": {
                                  "lineage": "http://qcmms.esa.int/prague_sealing_references_330.shp",
                                  "producersAccuracy": 91.4,
                                  "usersAccuracy": 90,
                                  "confusionMatrix": [
                                    [
                                      92,
                                      8
                                    ],
                                    [
                                      1,
                                      99
                                    ]
                                  ],
                                  "kappa": 85.3,
                                  "codingClasses": [
                                    "non-urban",
                                    "urban"
                                  ],
                                  "overallAccuracy": 90.2
                                },
                                "value": true
                              }
                            ]
                          },
                          "format": "geoTIFF",
                          "productType": "classification",
                          "availabilityTime": "2019-06-20T15:23:57Z"
                        },
                        "abstract": "The high resolution imperviousness product capture the percentage of soil sealing. Built-up areas are characterized by the substitution of the original (semi-) natural land cover or water surface with an artificial, often impervious cover. This product of imperviousness layer constitutes the main status layer. There is per-pixel estimates of impermeable cover of soil (soil sealing) and are mapped as the degree of imperviousness (0-100%). Imperviousness 2018 is the continuation of the existing HRL imperviousness status product for the 2018 reference year, but with an increase in spatial resolution from 20m to (now) 10m.",
                        "title": "IMD_2018_010m",
                        "links": {
                          "qualityReport": [
                            {
                              "href": "SERVER_URL/series/EOP:ESA:LP:UC1/datasets/IMD_2018_010m?httpAccept=application/x-ipynb%2Bjson",
                              "title": "Online quality report by QCMMS in Jupyter notebook format",
                              "type": "application/x-ipynb+json"
                            }
                          ],
                          "alternates": [
                            {
                              "href": "SERVER_URL/series/EOP:ESA:LP:UC1/datasets/IMD_2018_010m?httpAccept=application%2Fvnd.iso.19157-2",
                              "title": "Online quality report by QCMMS in ISO 19157-2 format",
                              "type": "application/vnd.iso.19157-2"
                            }
                          ],
                          "via": [
                            {
                              "href": "SERVER_URL/series/EOP:ESA:GR1:UC1/datasets",
                              "type": "application/geo+json",
                              "title": "Input data"
                            }
                          ]
                        },
                        "categories": [
                          {
                            "term": "https://earth.esa.int/concept/urban",
                            "label": "urban"
                          },
                          {
                            "term": "http://www.eionet.europa.eu/gemet/concept/4599",
                            "label": "land"
                          },
                          {
                            "term": "https://earth.esa.int/concept/sentinel-2",
                            "label": "Sentinel-2"
                          }
                        ],
                        "updated": "2020-06-17T16:27:10.01Z",
                        "qualifiedAttribution": [
                          {
                            "agent": [
                              {
                                "hasAddress": {
                                  "postal-code": "00044",
                                  "street-address": "Via Galileo Galilei CP. 64",
                                  "locality": "Frascati",
                                  "country-name": "Italy"
                                },
                                "phone": "tel:+39 06 94180777",
                                "name": "ESA/ESRIN",
                                "type": "Organization",
                                "uri": "http://www.earth.esa.int",
                                "email": "eohelp@eo.esa.int"
                              }
                            ],
                            "role": "originator",
                            "type": "Attribution"
                          }
                        ],
                        "acquisitionInformation": [
                          {
                            "instrument": {
                              "instrumentShortName": "MSI",
                              "id": "https://earth.esa.int/concept/s2-msi"
                            },
                            "platform": {
                              "platformShortName": "Sentinel-2",
                              "id": "https://earth.esa.int/concept/sentinel-2"
                            }
                          }
                        ],
                        "status": "PLANNED",
                        "additionalAttributes": {
                          "crs": "European ETRS89 LAEA",
                          "seasonal_window": [
                            5,
                            6
                          ],
                          "thematic_accuracy": 90,
                          "necessary_attributes": [
                            "raster_value",
                            " count",
                            " class_names"
                          ],
                          "product_focus": "classification",
                          "lpReference": "EN-EEA.IDM.R0.18.009_Annex_8 Table 11",
                          "geometric_accuracy": 0.5,
                          "raster_coding": [
                            {
                              "min": 0,
                              "max": 0,
                              "name": "all non-impervious areas"
                            },
                            {
                              "min": "1",
                              "max": "100",
                              "name": "imperviousness values"
                            },
                            {
                              "min": 254,
                              "max": 254,
                              "name": "unclassifiable (no satellite image available, or clouds, shadows, or snow)"
                            },
                            {
                              "min": 255,
                              "max": 255,
                              "name": "outside area"
                            }
                          ],
                          "temporal_coverage": "status",
                          "grid": "EEA Reference Grid",
                          "mmu_pixels": 1,
                          "data_type": "u8",
                          "geometric_resolution": 10
                        }
                      }
                    }
                  ],
                  "totalResults": 1,
                  "startIndex": "1",
                  "itemsPerPage": "10",
                  "id": "SERVER_URL/series/EOP:ESA:LP:UC1/datasets",
                  "type": "FeatureCollection",
                  "queries": {
                    "request": [
                      {
                        "eo:parentIdentifier": "EOP:ESA:LP:UC1",
                        "dc:type": "dataset",
                        "os:count": "10",
                        "os:startIndex": "1"
                      }
                    ]
                  },
                  "properties": {
                    "creator": "ESA Catalog",
                    "rights": "Copyright 2016-2018, European Space Agency",
                    "links": {
                      "search": [
                        {
                          "href": "SERVER_URL/series/EOP:ESA:LP:UC1/description",
                          "type": "application/opensearchdescription+xml",
                          "title": "search"
                        }
                      ],
                      "last": [
                        {
                          "href": "SERVER_URL/series/EOP:ESA:LP:UC1/datasets?startRecord=1",
                          "type": "application/geo+json",
                          "title": "last results"
                        }
                      ],
                      "profiles": [
                        {
                          "href": "http://www.opengis.net/spec/owc-geojson/1.0/req/core"
                        }
                      ],
                      "first": [
                        {
                          "href": "SERVER_URL/series/EOP:ESA:LP:UC1/datasets?startRecord=1",
                          "type": "application/geo+json",
                          "title": "first results"
                        }
                      ]
                    },
                    "title": "ESA Catalog - Search Response",
                    "lang": "en",
                    "updated": "2020-10-15T10:51:55Z",
                    "authors": [
                      {
                        "name": "ESA Catalog",
                        "type": "Agent",
                        "email": "eohelp@eo.esa.int"
                      }
                    ]
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad request (invalid parameter)"
          },
          "415": {
            "description": "Unsupported Media Type."
          },
          "500": {
            "description": "Unexpected error"
          }
        }
      }
    },
    "/series/{seriesId}/datasets/{datasetId}": {
      "get": {
        "description": "Search a dataset from the catalogue.",
        "operationId": "Search",
        "tags": [
          "Dataset"
        ],
        "parameters": [
          {
            "name": "seriesId",
            "in": "path",
            "x-value": "{eo:parentIdentifier}",
            "required": true,
            "description": "Series identifier.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "datasetId",
            "in": "path",
            "x-value": "{geo:uid}",
            "required": true,
            "description": "Dataset identifier.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "httpAccept",
            "in": "query",
            "description": "Query parameter to define expected reponse type. Types: 'application/x-ipynb+json' and 'application/vnd.iso.19157-2' are only supported by Land product",
            "required": false,
            "schema": {
              "type": "string",
              "default": "application/geo+json",
              "enum": [
                "application/geo+json",
                "application/x-ipynb+json",
                "application/vnd.iso.19157-2"
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The requested dataset",
            "content": {
              "application/geo+json": {
                "schema": {
                  "$ref": "#/components/schemas/FeatureCollection"
                },
                "example": {
                  "features": [
                    {
                      "geometry": {
                        "coordinates": [
                          [
                            [
                              14.186107522713066,
                              50.14002219508509
                            ],
                            [
                              14.348557265087889,
                              50.190863360699744
                            ],
                            [
                              14.52707194102769,
                              50.22238131434859
                            ],
                            [
                              14.70471208561416,
                              50.15631934376189
                            ],
                            [
                              14.762121752264225,
                              50.11661835893974
                            ],
                            [
                              14.776263231679243,
                              50.08705944886458
                            ],
                            [
                              14.759382059466128,
                              50.04888224005577
                            ],
                            [
                              14.736099726431998,
                              50.035462644701234
                            ],
                            [
                              14.725798743272927,
                              49.98844155508602
                            ],
                            [
                              14.673311418036075,
                              49.95524536878365
                            ],
                            [
                              14.567718909876344,
                              49.963098371814596
                            ],
                            [
                              14.393611244433437,
                              49.89671406657247
                            ],
                            [
                              14.300307718430275,
                              49.9106994061699
                            ],
                            [
                              14.262366285871089,
                              49.939623961782445
                            ],
                            [
                              14.257705254305824,
                              49.96457124584049
                            ],
                            [
                              14.187100684005998,
                              50.036319364709136
                            ],
                            [
                              14.157501941761778,
                              50.09104091038224
                            ],
                            [
                              14.161937344554374,
                              50.12127156190347
                            ],
                            [
                              14.186107522713066,
                              50.14002219508509
                            ]
                          ]
                        ],
                        "type": "Polygon"
                      },
                      "id": "SERVER_URL/series/EOP:ESA:LP:UC1/datasets/IMD_2018_010m",
                      "type": "Feature",
                      "properties": {
                        "date": "2020-06-17T16:27:10.01Z",
                        "identifier": "IMD_2018_010m",
                        "kind": "http://purl.org/dc/dcmitype/Dataset",
                        "parentIdentifier": "EOP:ESA:LP:UC1",
                        "productInformation": {
                          "referenceSystemIdentifier": "http://www.opengis.net/def/crs/EPSG/0/3035",
                          "qualityInformation": {
                            "qualityIndicators": [
                              {
                                "lineage": "http://qcmms.esa.int/Mx_vpx_v0.9",
                                "isMeasurementOf": "http://qcmms.esa.int/quality-indicators/#ipForLpInformationMetric",
                                "vpxCoverage": {
                                  "2018": {
                                    "min": 0,
                                    "max": 1,
                                    "gapPct": 7,
                                    "mask": "http://93.91.57.111/UC1/image_products/vpx_coverage_10m.jpg"
                                  }
                                },
                                "generatedAtTime": "2020-06-17T16:27:09.98Z",
                                "value": true,
                                "fitnessForPurpose": "PARTIAL"
                              },
                              {
                                "lineage": "http://qcmms.esa.int/QCMMS_QCManager_v1.0",
                                "isMeasurementOf": "http://qcmms.esa.int/quality-indicators/#lpInterpretationMetric",
                                "densityCover": {
                                  "mae": 10.25,
                                  "lineage": "http://qcmms.esa.int/Mx_sealing_simple_v0.9",
                                  "rmse": 13.22,
                                  "pearsonR": 0.69,
                                  "mse": 174.86
                                },
                                "generatedAtTime": "2020-06-17T16:27:20.58Z",
                                "classification": {
                                  "lineage": "http://qcmms.esa.int/Mx_sealing_simple_v0.9",
                                  "producersAccuracy": 99,
                                  "usersAccuracy": 92,
                                  "confusionMatrix": [
                                    [
                                      92,
                                      8
                                    ],
                                    [
                                      1,
                                      99
                                    ]
                                  ],
                                  "kappa": 88,
                                  "codingClasses": [
                                    "non-urban",
                                    "urban"
                                  ],
                                  "overallAccuracy": 91
                                },
                                "value": true
                              },
                              {
                                "lineage": "http://qcmms.esa.int/QCMMS_QCManager_v1.0",
                                "metadataCompliancy": true,
                                "isMeasurementOf": "http://qcmms.esa.int/quality-indicators/#lpMetadataControlMetric",
                                "metadataAvailable": true,
                                "metadataSpecification": "INSPIRE",
                                "generatedAtTime": "2020-06-17T16:27:20.59Z",
                                "value": true
                              },
                              {
                                "epsg": "3035",
                                "lineage": "http://qcmms.esa.int/QCMMS_QCManager_v1.0",
                                "rasterFormat": "GeoTIFF",
                                "isMeasurementOf": "http://qcmms.esa.int/quality-indicators/#lpOrdinaryControlMetric",
                                "read": true,
                                "dataType": "u8",
                                "generatedAtTime": "2020-06-17T16:27:20.59Z",
                                "extentUlLr": [
                                  4621500,
                                  3019160,
                                  4659740,
                                  2988580
                                ],
                                "value": true,
                                "xRes": 10,
                                "yRes": 10,
                                "aoiCoveragePct": 100
                              },
                              {
                                "lineage": "http://qcmms.esa.int/QCMMS_QCManager_v1.0",
                                "isMeasurementOf": "http://qcmms.esa.int/quality-indicators/#lpThematicValidationMetric",
                                "densityCover": {
                                  "mae": 10.2,
                                  "lineage": "http://qcmms.esa.int/prague_sealing_references_330.shp",
                                  "codingValues": {
                                    "unclassified": 254,
                                    "sealingMax": 100,
                                    "sealingMin": 1,
                                    "outsideAoi": 254,
                                    "non-sealing": 0
                                  },
                                  "rmse": 11,
                                  "pearsonR": 0.71,
                                  "mse": 120.3
                                },
                                "generatedAtTime": "2020-06-17T16:27:20.59Z",
                                "classification": {
                                  "lineage": "http://qcmms.esa.int/prague_sealing_references_330.shp",
                                  "producersAccuracy": 91.4,
                                  "usersAccuracy": 90,
                                  "confusionMatrix": [
                                    [
                                      92,
                                      8
                                    ],
                                    [
                                      1,
                                      99
                                    ]
                                  ],
                                  "kappa": 85.3,
                                  "codingClasses": [
                                    "non-urban",
                                    "urban"
                                  ],
                                  "overallAccuracy": 90.2
                                },
                                "value": true
                              }
                            ]
                          },
                          "format": "geoTIFF",
                          "productType": "classification",
                          "availabilityTime": "2019-06-20T15:23:57Z"
                        },
                        "abstract": "The high resolution imperviousness product capture the percentage of soil sealing. Built-up areas are characterized by the substitution of the original (semi-) natural land cover or water surface with an artificial, often impervious cover. This product of imperviousness layer constitutes the main status layer. There is per-pixel estimates of impermeable cover of soil (soil sealing) and are mapped as the degree of imperviousness (0-100%). Imperviousness 2018 is the continuation of the existing HRL imperviousness status product for the 2018 reference year, but with an increase in spatial resolution from 20m to (now) 10m.",
                        "title": "IMD_2018_010m",
                        "links": {
                          "qualityReport": [
                            {
                              "href": "SERVER_URL/series/EOP:ESA:LP:UC1/datasets/IMD_2018_010m?httpAccept=application/x-ipynb%2Bjson",
                              "title": "Online quality report by QCMMS in Jupyter notebook format",
                              "type": "application/x-ipynb+json"
                            }
                          ],
                          "alternates": [
                            {
                              "href": "SERVER_URL/series/EOP:ESA:LP:UC1/datasets/IMD_2018_010m?httpAccept=application%2Fvnd.iso.19157-2",
                              "title": "Online quality report by QCMMS in ISO 19157-2 format",
                              "type": "application/vnd.iso.19157-2"
                            }
                          ],
                          "via": [
                            {
                              "href": "SERVER_URL/series/EOP:ESA:GR1:UC1/datasets",
                              "type": "application/geo+json",
                              "title": "Input data"
                            }
                          ]
                        },
                        "categories": [
                          {
                            "term": "https://earth.esa.int/concept/urban",
                            "label": "urban"
                          },
                          {
                            "term": "http://www.eionet.europa.eu/gemet/concept/4599",
                            "label": "land"
                          },
                          {
                            "term": "https://earth.esa.int/concept/sentinel-2",
                            "label": "Sentinel-2"
                          }
                        ],
                        "updated": "2020-06-17T16:27:10.01Z",
                        "qualifiedAttribution": [
                          {
                            "agent": [
                              {
                                "hasAddress": {
                                  "postal-code": "00044",
                                  "street-address": "Via Galileo Galilei CP. 64",
                                  "locality": "Frascati",
                                  "country-name": "Italy"
                                },
                                "phone": "tel:+39 06 94180777",
                                "name": "ESA/ESRIN",
                                "type": "Organization",
                                "uri": "http://www.earth.esa.int",
                                "email": "eohelp@eo.esa.int"
                              }
                            ],
                            "role": "originator",
                            "type": "Attribution"
                          }
                        ],
                        "acquisitionInformation": [
                          {
                            "instrument": {
                              "instrumentShortName": "MSI",
                              "id": "https://earth.esa.int/concept/s2-msi"
                            },
                            "platform": {
                              "platformShortName": "Sentinel-2",
                              "id": "https://earth.esa.int/concept/sentinel-2"
                            }
                          }
                        ],
                        "status": "PLANNED",
                        "additionalAttributes": {
                          "crs": "European ETRS89 LAEA",
                          "seasonal_window": [
                            5,
                            6
                          ],
                          "thematic_accuracy": 90,
                          "necessary_attributes": [
                            "raster_value",
                            " count",
                            " class_names"
                          ],
                          "product_focus": "classification",
                          "lpReference": "EN-EEA.IDM.R0.18.009_Annex_8 Table 11",
                          "geometric_accuracy": 0.5,
                          "raster_coding": [
                            {
                              "min": 0,
                              "max": 0,
                              "name": "all non-impervious areas"
                            },
                            {
                              "min": "1",
                              "max": "100",
                              "name": "imperviousness values"
                            },
                            {
                              "min": 254,
                              "max": 254,
                              "name": "unclassifiable (no satellite image available, or clouds, shadows, or snow)"
                            },
                            {
                              "min": 255,
                              "max": 255,
                              "name": "outside area"
                            }
                          ],
                          "temporal_coverage": "status",
                          "grid": "EEA Reference Grid",
                          "mmu_pixels": 1,
                          "data_type": "u8",
                          "geometric_resolution": 10
                        }
                      }
                    }
                  ],
                  "totalResults": 1,
                  "startIndex": "1",
                  "itemsPerPage": "10",
                  "id": "SERVER_URL/series/EOP:ESA:LP:UC1/datasets/IMD_2018_010m",
                  "type": "FeatureCollection",
                  "queries": {
                    "request": [
                      {
                        "eo:parentIdentifier": "EOP:ESA:LP:UC1",
                        "dc:type": "dataset",
                        "geo:uid": "IMD_2018_010m",
                        "os:count": "10",
                        "os:startIndex": "1"
                      }
                    ]
                  },
                  "properties": {
                    "creator": "ESA Catalog",
                    "rights": "Copyright 2016-2018, European Space Agency",
                    "links": {
                      "search": [
                        {
                          "href": "SERVER_URL/series/EOP:ESA:LP:UC1/description",
                          "type": "application/opensearchdescription+xml",
                          "title": "search"
                        }
                      ],
                      "profiles": [
                        {
                          "href": "http://www.opengis.net/spec/owc-geojson/1.0/req/core"
                        }
                      ]
                    },
                    "title": "ESA Catalog - Search Response",
                    "lang": "en",
                    "updated": "2020-10-15T10:26:57Z",
                    "authors": [
                      {
                        "name": "ESA Catalog",
                        "type": "Agent",
                        "email": "eohelp@eo.esa.int"
                      }
                    ]
                  }
                }
              },
              "application/x-ipynb+json": {
                "schema": {
                  "$ref": "#/components/schemas/Feature"
                },
                "example": {
                  "nbformat_minor": 0,
                  "metadata": {
                    "language_info": {
                      "pygments_lexer": "ipython3",
                      "nbconvert_exporter": "python",
                      "codemirror_mode": {
                        "name": "ipython",
                        "version": 3
                      },
                      "name": "python",
                      "file_extension": ".py",
                      "mimetype": "text/x-python",
                      "version": "3.7.3"
                    },
                    "colab": {
                      "provenance": [],
                      "collapsed_sections": [],
                      "name": "QCMMS-Report_hideCode.ipynb",
                      "toc_visible": true
                    },
                    "kernelspec": {
                      "name": "python3",
                      "language": "python",
                      "display_name": "Python 3"
                    }
                  },
                  "cells": [
                    {
                      "outputs": [],
                      "metadata": {
                        "colab_type": "code",
                        "colab": {},
                        "cellView": "code",
                        "id": "IUjsVlhllse_"
                      },
                      "execution_count": null,
                      "source": [
                        "#@title \n",
                        "catalogueEndpoint = 'SERVER_URL'\n",
                        "lpProductIdentifier='IMD_2018_010m'\n",
                        "lpParentIdentifier= 'EOP:ESA:LP:UC1'\n",
                        "debug = False\n",
                        "#@title Basic functions\n",
                        "import json, requests\n",
                        "import pandas as pd\n",
                        "import math\n",
                        "import matplotlib.pyplot as plt\n",
                        "\n",
                        "from IPython.display import display, HTML\n",
                        "import ipywidgets as widgets\n",
                        "\n",
                        "lpUrl=catalogueEndpoint + '/'+ 'series'+'/' + lpParentIdentifier + '/datasets/'+lpProductIdentifier\n",
                        "ipUrl=''\n",
                        "lpMd={}\n",
                        "platforms=[]\n",
                        "fgNbr = 0\n",
                        "references=[]\n",
                        "geometric_resolution=10\n",
                        "\n",
                        "processingLevelDefs=[\"1C\",\"L1TP\",\"L1GT\",\"L2A\", \"L2\"]\n",
                        "maxRecords = 10\n",
                        "\n",
                        "pd.set_option('display.html.table_schema', True)\n",
                        "\n",
                        "def getMetric(metric,feature):\n",
                        "    result={}\n",
                        "    metrics=feature['properties']['productInformation']['qualityInformation']['qualityIndicators']\n",
                        "    lenMetrics= len(metrics)\n",
                        "    for i in range(lenMetrics):\n",
                        "      if (metrics[i]['isMeasurementOf'] == metric): \n",
                        "        result=metrics[i]\n",
                        "    if (result == {} and debug):\n",
                        "      print(\"metric \", metric,\"not found in \", feature['properties']['identifier'] )\n",
                        "    return result\n",
                        "\n",
                        "def getProcessingLevelIndex(processingLevel):\n",
                        "  index=-1\n",
                        "  for i in range(len(processingLevelDefs)):\n",
                        "    if (processingLevelDefs[i] == processingLevel ): \n",
                        "      index=i\n",
                        "  return index\n",
                        "\n",
                        "def generateFigureLabel(fgNbr,label):\n",
                        "  lfgNbr=fgNbr+1\n",
                        "  display(widgets.HTML(\n",
                        "    value='<i>Figure '+ str(lfgNbr) +': ' + label+'</i>'\n",
                        "    ))\n",
                        "  return lfgNbr\n",
                        "\n",
                        "def getFigureLabel(fgNbr,label):\n",
                        "  return 'Figure '+ str(fgNbr) +': ' + label\n",
                        "\n",
                        "tableNbr=0\n",
                        "def generateTableLabel(tableNbr,label):\n",
                        "  lNbr=tableNbr+1\n",
                        "  display(widgets.HTML(\n",
                        "    value='<i>Table '+ str(lNbr) +': ' + label+'</i>'\n",
                        "    ))\n",
                        "  return lNbr\n",
                        "\n",
                        "def displayImage(url):\n",
                        "  display(widgets.HTML(\n",
                        "  value= '<img width=\"500\" height=\"500\" src=\"'+url+'\">' \n",
                        "    ))\n",
                        "#@title Retrieving Land Product\n",
                        "def getLandProduct():\n",
                        "  querystring={}\n",
                        "  nbLp=0\n",
                        "  lpMd={}\n",
                        "  #print(lpUrl)\n",
                        "  response = requests.get(lpUrl, params=querystring)\n",
                        "  pyresult = json.loads(response.text)\n",
                        "  try:\n",
                        "    nbLp  = len(pyresult['features'])\n",
                        "  except KeyError:\n",
                        "    pass\n",
                        "  if (nbLp == 0):\n",
                        "    print(\"Land Product \" + lpProductIdentifier + \"(\"+ lpParentIdentifier +\") is not found\" )\n",
                        "  else:\n",
                        "    lpMd = pyresult['features'][0]\n",
                        "  return lpMd\n",
                        "\n",
                        "def cvtRasterCoding(rasterCodings):\n",
                        "  res=''\n",
                        "  for i in range(len(rasterCodings)):\n",
                        "    res=res+cvtSingleRasterCoding(rasterCodings[i])\n",
                        "    res=res + '\\\\n'\n",
                        "  return res\n",
                        "\n",
                        "def cvtSingleRasterCoding(rasterCoding):\n",
                        "  res=''\n",
                        "  try:\n",
                        "    min=toString(rasterCoding['min'])\n",
                        "    max=toString(rasterCoding['max'])\n",
                        "    name=toString(rasterCoding['name'])\n",
                        "    if (min == max):\n",
                        "\t    res=min+': ' + name\n",
                        "    else:\n",
                        "      res=min + '-' + max  + ': ' + name\n",
                        "  except KeyError:\n",
                        "    pass\n",
                        "  return res\n",
                        "\n",
                        "def toString(value):\n",
                        "  if isinstance(value,int):\n",
                        "    return str(value)\n",
                        "  elif isinstance(value,dict):\n",
                        "    return json.dumps(value)\n",
                        "  else:\n",
                        "    return value\n",
                        "\n",
                        "def getLpAttribute(lpMdProperties,attribute1,attribute2):\n",
                        "  res=''\n",
                        "  try:\n",
                        "    if (attribute2 == 'raster_coding'):\n",
                        "      res=cvtRasterCoding(lpMdProperties[attribute1][attribute2])\n",
                        "    elif (attribute2 != ''):\n",
                        "      res=lpMdProperties[attribute1][attribute2]\n",
                        "      if isinstance(res, list):\n",
                        "        res=\",\".join(map(str,res))\n",
                        "    else:\n",
                        "      res=lpMdProperties[attribute1]\n",
                        "  except KeyError:\n",
                        "        pass\n",
                        "  return res \n",
                        "lpMd=getLandProduct()\n",
                        "#@title Retrieving Related Image Products\n",
                        "def initImageProductsUrl():\n",
                        "  url=''\n",
                        "  lp=getLandProduct()\n",
                        "  if lp != {}:\n",
                        "    try:\n",
                        "      url=lp['properties']['links']['via'][0]['href']\n",
                        "    except KeyError:\n",
                        "      print('Missing via links to Image Products the Land Product') \n",
                        "  return url\n",
                        "ipUrl=initImageProductsUrl()\n",
                        "#@title Retrieving Related Platforms\n",
                        "def initPlatforms(lpMd):\n",
                        "  nb_platforms=len(lpMd['properties']['acquisitionInformation'])\n",
                        "  lplatforms= [''] * nb_platforms    \n",
                        "  for i in range(len(lpMd['properties']['acquisitionInformation'])):\n",
                        "      lplatforms[i]=lpMd['properties']['acquisitionInformation'][i]['platform']['platformShortName']\n",
                        "  return lplatforms\n",
                        "platforms=initPlatforms(lpMd)\n",
                        "\n",
                        "def harmonized():\n",
                        "# nbr of platforms is used to decide if we are in multisensor UC.\n",
                        "# if yes there some additional information for the harmonization.\n",
                        "  if (len(platforms) > 1):\n",
                        "    return True;\n",
                        "  else:\n",
                        "    return False;\n",
                        "\n",
                        "\n",
                        "def countImageProductByMetric(metric,metricValue):\n",
                        "   # metric can take values\n",
                        "   # degradedDataPercentageMetric\t\t\n",
                        "   # degradedAncillaryDataPercentageMetric\t\t\n",
                        "   # formatCorrectnessMetric\n",
                        "   # generalQualityMetric\t\t\n",
                        "   # geometricQualityMetric\t\t\n",
                        "   # radiometricQualityMetric\t\t\n",
                        "   # sensorQualityMetric\t\n",
                        "   # feasibilityControlMetric\t\t\n",
                        "   # deliveryControlMetric\t\t\n",
                        "   # ordinaryControlMetric\t\t\n",
                        "   # detailedControlMetric\n",
                        "  querystring={}\n",
                        "  querystring['maximumRecords'] = 1\n",
                        "  if metric != '':\n",
                        "    querystring['specificationTitle'] = metric\n",
                        "    querystring['degree'] = metricValue\n",
                        "  response = requests.get(ipUrl, params=querystring)\n",
                        "  pyresult= json.loads(response.text)\n",
                        "  return pyresult['totalResults']\n",
                        "#\n",
                        "# build status for each steps\n",
                        "#\n",
                        "#\n",
                        "# return True if the metric is associated to LP \n",
                        "# check if metric contains lp\n",
                        "def lpMetric(metric):\n",
                        "  if metric.lower().rfind('lp') == -1:\n",
                        "    return False\n",
                        "  else:\n",
                        "    return True\n",
                        "\n",
                        "def  getLpMetricStatus(metricName):\n",
                        "  metricPrefix='http://qcmms.esa.int/quality-indicators/#'\n",
                        "  metric=getMetric(metricPrefix+metricName,lpMd)\n",
                        "  #print(\"metric id\", metricPrefix+metricName)\n",
                        "  #print(\"lpMd\",lpMd)\n",
                        "  #print(\"metric\", metric)\n",
                        "  if metric != {}:\n",
                        "    executed=True\n",
                        "  else:\n",
                        "    executed=False\n",
                        "  applicable=True\n",
                        "  if metricName == 'lpInterpretationMetric' and harmonized(): \n",
                        "    applicable=False\n",
                        "  \n",
                        "  nbPass=0\n",
                        "  nbFailed=0\n",
                        "  try:\n",
                        "    if metric['value']:\n",
                        "      nbPass=1\n",
                        "    else:\n",
                        "      nbFailed=1\n",
                        "  except KeyError:\n",
                        "    pass\n",
                        "  \n",
                        "  result={'Applicable': applicable, 'Executed' : executed, 'PASS': nbPass, 'FAILED' : nbFailed }\n",
                        "  #print(\"metric name\", metricName, result)\n",
                        "  return result\n",
                        "\n",
                        "def getMetricStatus(metric):\n",
                        "  if not lpMetric(metric):\n",
                        "    nbPass=countImageProductByMetric(metric,'true')\n",
                        "    nbFailed=countImageProductByMetric(metric,'false')\n",
                        "    applicable=True\n",
                        "    if not harmonized() and metric == 'harmonizationControlMetric':\n",
                        "      applicable=False\n",
                        "    \n",
                        "    if nbPass == 0 and nbFailed == 0:\n",
                        "      executed=False\n",
                        "    else:\n",
                        "      executed=True\n",
                        "    return {'Applicable': applicable, 'Executed' : executed, 'PASS': nbPass, 'FAILED' : nbFailed }\n",
                        "  else:\n",
                        "    return getLpMetricStatus(metric)\n",
                        "\n",
                        "\n",
                        "MetricsStatusVct=[\n",
                        "                  {'Applicable': True, 'Executed' : True, 'PASS': 1, 'FAILED' :0 },\n",
                        "                  getMetricStatus('feasibilityControlMetric'),\n",
                        "                  getMetricStatus('deliveryControlMetric'),\n",
                        "                  getMetricStatus('ordinaryControlMetric'),\n",
                        "                  getMetricStatus('detailedControlMetric'),\n",
                        "                  getMetricStatus('harmonizationControlMetric'),\n",
                        "                  getMetricStatus('ipForLpInformationMetric'),\n",
                        "                  getMetricStatus('lpInterpretationMetric'),\n",
                        "                  getMetricStatus('lpMetadataControlMetric'),\n",
                        "                  getMetricStatus('lpOrdinaryControlMetric'),\n",
                        "                  getMetricStatus('lpThematicValidationMetric')\n",
                        "                 ]\n",
                        "IndexFeasibility=1\n",
                        "IndexDelivery=2\n",
                        "IndexOrdinary=3\n",
                        "IndexDetailed=4\n",
                        "IndexHarmonization=5\n",
                        "IndexIpForLp=6\n",
                        "IndexLpInterpretation=7\n",
                        "IndexLpMetadata=8\n",
                        "IndexLpOrdinary=9\n",
                        "IndexLpThematic=10\n",
                        "#MetricsStatusVct[IndexFeasibility]['Executed']=False\n",
                        "#MetricsStatusVct[IndexDelivery]['Applicable']=False\n",
                        "\n",
                        "\n",
                        "def alreadyExecuted(index):\n",
                        "  if not MetricsStatusVct[index]['Applicable']:\n",
                        "    print(\"This step is not applicable.\")\n",
                        "    return False\n",
                        "  if not MetricsStatusVct[index]['Executed']:\n",
                        "    print(\"This step has not yet been executed.\")\n",
                        "    return False\n",
                        "  return True\n",
                        "#\n",
                        "# compute the nbr of PASS/FAILED  for overall assessment and to decide if a step has already been executed.\n",
                        "#\n",
                        "\n",
                        "IPsMetricsStatusVct=[\n",
                        "                     {'Metric' :'1. FeasibilityControl',  'Value' : 'PASS' ,  'Nbr' : MetricsStatusVct[IndexFeasibility]['PASS']},\t\n",
                        "                     {'Metric' :'1. FeasibilityControl',  'Value' : 'FAILED' ,'Nbr' : MetricsStatusVct[IndexFeasibility]['FAILED'] },\n",
                        "                     {'Metric' :'2. DeliveryControl',     'Value' : 'PASS' ,  'Nbr' : MetricsStatusVct[IndexDelivery]['PASS'] },\t\n",
                        "                     {'Metric' :'2. DeliveryControl',     'Value' : 'FAILED' ,'Nbr' : MetricsStatusVct[IndexDelivery]['FAILED'] },\n",
                        "                     {'Metric' :'3a. OrdinaryControl',    'Value' : 'PASS' ,  'Nbr' : MetricsStatusVct[IndexOrdinary]['PASS'] },\n",
                        "                     {'Metric' :'3a. OrdinaryControl',    'Value' : 'FAILED' ,'Nbr' : MetricsStatusVct[IndexOrdinary]['FAILED'] },\t\n",
                        "                     {'Metric' :'3b. DetailedControl',    'Value' : 'PASS' ,  'Nbr' : MetricsStatusVct[IndexDetailed]['PASS'] },\t\n",
                        "                     {'Metric' :'3b. DetailedControl',    'Value' : 'FAILED' ,'Nbr' : MetricsStatusVct[IndexDetailed]['FAILED'] }\t]\n",
                        "if MetricsStatusVct[IndexHarmonization]['Applicable']:\n",
                        "  IPsMetricsStatusVct.append({'Metric' :'4a. HarmonizationControl',    'Value' : 'PASS' ,  'Nbr' : MetricsStatusVct[IndexHarmonization]['PASS'] })\n",
                        "  IPsMetricsStatusVct.append({'Metric' :'4a. HarmonizationControl',    'Value' : 'FAILED' ,  'Nbr' : MetricsStatusVct[IndexHarmonization]['FAILED']  })\n",
                        "\n",
                        "def generateDefinitions():\n",
                        "  def0= '<tr><td>'+'Circular Error at the 90th percentile' + '</td><td>'+ 'A minimum of 90 percent of the points are included in the stated CE90 circle.' + '</td></tr>'\n",
                        "  def1= '<tr><td>'+'Image Product' + '</td><td>'+ 'Satellite image data with metadata used as input to Land Mapping Production.' + '</td></tr>'\n",
                        "  def2= '<tr><td>'+'Land Product'+ '</td><td>' + 'Land Mapping or Monitoring Product as e.g. Land Cover Map.'+'</td></tr>' \n",
                        "  def3= '<tr><td>'+'Land Product Specification Table'+'</td><td>'+ 'Set of parameters that defines the Land Product and the required Image Products.'+'</td></tr>' \n",
                        "  def4= '<tr><td>'+'Root Mean Square Error' +'</td><td>'+  'The standard deviation of the residuals (prediction errors). Residuals are a measure of how far from the regression line data points are; RMSE is a measure of how spread out these residuals are. In other words, it tells you how concentrated the data is around the line of best fit.' +'</td></tr>' \n",
                        "  definitions= '<table  border=1 width=80%>' + def0 + def1 + def2 + def3 + '</table>'\n",
                        "  display(widgets.HTML(\n",
                        "    value=definitions\n",
                        "    ))\n",
                        "\n",
                        "def generateAbbreviations():\n",
                        "  def0a= '<tr><td>'+'AOI' + '</td><td>'+ 'Area Of Interest' + '</td></tr>'\n",
                        "  def0b= '<tr><td>'+'CE90' + '</td><td>'+ 'Circular Error at the 90th percentile' + '</td></tr>'\n",
                        "  def0c= '<tr><td>'+'CRS' + '</td><td>'+ 'Coordinate Reference Systems' + '</td></tr>'\n",
                        "  def1= '<tr><td>'+'EO' + '</td><td>'+ 'Earth Observation' + '</td></tr>'\n",
                        "  def2= '<tr><td>'+'HR' + '</td><td>'+ 'High Resolution' + '</td></tr>'\n",
                        "  def3= '<tr><td>'+'HRL' + '</td><td>'+ 'High Resolution Layer' + '</td></tr>'\n",
                        "  def4= '<tr><td>'+'IP' + '</td><td>'+ 'Image Product' + '</td></tr>'\n",
                        "  def5= '<tr><td>'+'INSPIRE' + '</td><td>'+ 'Infrastructure for Spatial Information in Europe' + '</td></tr>'\n",
                        "  def6= '<tr><td>'+'LCCM' + '</td><td>'+ 'Land Cover Continuous Monitoring' + '</td></tr>'\n",
                        "  def7= '<tr><td>'+'LP'+  '</td><td>' + 'Land Product' + '</td></tr>'\n",
                        "  def8a= '<tr><td>'+'MAE'+  '</td><td>' + 'Mean Absolute Error' + '</td></tr>'\n",
                        "  def8b= '<tr><td>'+'MMU'+  '</td><td>' + 'Minimum Mapping Unit' + '</td></tr>'\n",
                        "  def8c= '<tr><td>'+'MSE'+  '</td><td>' + 'Mean Square Error' + '</td></tr>'\n",
                        "  def9= '<tr><td>'+'RMSE'+  '</td><td>' + 'Root Mean Square Error' + '</td></tr>'\n",
                        "  def10= '<tr><td>'+'VHR'+  '</td><td>' + 'Very High Resolution' + '</td></tr>'\n",
                        "  definitions= '<table border=1 width=80%>' + def0a+ def0b+ def0c+ def1 + def2 + def3 + def4 + def5 + def6 + def7 + def8a + def8b + def8c+ def9+ def10+'</table>'\n",
                        "  display(widgets.HTML(\n",
                        "    value=definitions\n",
                        "    ))\n",
                        "\n",
                        "#@title Generate Land Product Definition\n",
                        "def generate_lp_definition_report(tableNbr):\n",
                        "  table_title =['Parameter','Value/Description']\n",
                        "  \n",
                        "  table_report = []\n",
                        "  lpMd = getLandProduct()\n",
                        "  if(lpMd != {}):\n",
                        "    abstract=lpMd['properties']['abstract']\n",
                        "    \n",
                        "    display(widgets.HTML(\n",
                        "       value= abstract ))\n",
                        "    display(widgets.HTML(value='<br>'))\n",
                        "    tableNbr=generateTableLabel(tableNbr,'Land Product Specification Table')\n",
                        "    geometric_resolution=getLpAttribute(lpMd['properties'],'additionalAttributes','geometric_resolution')\n",
                        "\n",
                        "    table_report=[\n",
                        "      ['Product',getLpAttribute(lpMd['properties'],'title','')],\n",
                        "      ['Product focus',getLpAttribute(lpMd['properties'],'additionalAttributes','product_focus')],   \n",
                        "      ['Geometric resolution',str(getLpAttribute(lpMd['properties'],'additionalAttributes','geometric_resolution'))+'m'],\n",
                        "      ['Target CRS',getLpAttribute(lpMd['properties'],'additionalAttributes','crs')], \n",
                        "      ['Grid',getLpAttribute(lpMd['properties'],'additionalAttributes','grid')], \n",
                        "      ['Geometric accuracy',str(getLpAttribute(lpMd['properties'],'additionalAttributes','geometric_accuracy'))+' pixel'], \n",
                        "      ['Thematic accuracy',str(getLpAttribute(lpMd['properties'],'additionalAttributes','thematic_accuracy'))+'%'], \n",
                        "      ['MMU',str(getLpAttribute(lpMd['properties'],'additionalAttributes','mmu_pixels'))+' pixel'],  \n",
                        "      ['Necessary attributes',getLpAttribute(lpMd['properties'],'additionalAttributes','necessary_attributes')],\n",
                        "      ['Raster coding',getLpAttribute(lpMd['properties'],'additionalAttributes','raster_coding')],\n",
                        "      ['Data type',getLpAttribute(lpMd['properties'],'additionalAttributes','data_type')],\n",
                        "      ['Coverage area',getLpAttribute(lpMd['properties'],'additionalAttributes','coverage_area')],\n",
                        "      ['Reference year',getLpAttribute(lpMd['properties'],'additionalAttributes','reference_year')],\n",
                        "      ['Seasonal window',getLpAttribute(lpMd['properties'],'additionalAttributes','seasonal_window')],\n",
                        "      ['Temporal coverage',getLpAttribute(lpMd['properties'],'additionalAttributes','temporal_coverage')]              \n",
                        "    ]\n",
                        "    table_index = ['','','','','','','','','','','','','','','']\n",
                        "    pd_report = pd.DataFrame(table_report , index=table_index,columns = table_title)\n",
                        "    \n",
                        "    #pd_report.head()\n",
                        "    pretty_print(pd_report,'')\n",
                        "    #display(pd_report)\n",
                        "    return  {\"tableNbr\" : tableNbr,\n",
                        "             \"geometric_resolution\" : geometric_resolution\n",
                        "            }\n",
                        "   \n",
                        "\n",
                        "#@title Generate Feasibility Control Report\n",
                        "def generate_feasibility_control_report(platform):\n",
                        "  querystring = {}\n",
                        "  querystring['maximumRecords'] = maxRecords\n",
                        "  querystring['platform'] = platform\n",
                        "  table_title =['Format correctness','General quality', 'Geometric quality', 'Radiometric quality', 'Sensor quality', 'Total']\n",
                        "  metrics=['formatCorrectnessMetric','generalQualityMetric','geometricQualityMetric','radiometricQualityMetric','sensorQualityMetric','feasibilityControlMetric']\n",
                        "  degrees=['true','false']\n",
                        "  table_report=[ [0]*len(table_title) for i in range(len(degrees))]\n",
                        "  for i in range(len(degrees)):\n",
                        "    querystring['degree'] = degrees[i]\n",
                        "    for j in range (len(metrics)):\n",
                        "      querystring['specificationTitle'] = metrics[j]\n",
                        "      response = requests.get(ipUrl, params=querystring)\n",
                        "      table_report[i][j]=json.loads(response.text)['totalResults'] \n",
                        "  pd_report = pd.DataFrame(table_report , index = ['TRUE', 'FALSE'], columns = table_title)\n",
                        "  display(pd_report)\n",
                        "  display(widgets.HTML(value='<br>'))\n",
                        "\n",
                        "\n",
                        "#@title Generate Frequency Plot of Cloud Cover\n",
                        "\n",
                        "def generateHist(fgNbr,platform):\n",
                        "  querystring = {}\n",
                        "  cloudCvPctVt=[]\n",
                        "  querystring['maximumRecords'] = maxRecords\n",
                        "  querystring['platform'] = platform\n",
                        "  totalResults=1\n",
                        "  startIndex=1\n",
                        "  while (startIndex<=totalResults):\n",
                        "    querystring['startRecord'] = startIndex\n",
                        "    response = requests.get(ipUrl, params=querystring)\n",
                        "    pyresult= json.loads(response.text)\n",
                        "    lenFeatures= len(pyresult['features'])\n",
                        "    startIndex=startIndex+maxRecords\n",
                        "    totalResults=pyresult['totalResults']\n",
                        "    for i in range(lenFeatures):\n",
                        "      try:\n",
                        "        cloudCvPctVt.append(pyresult['features'][i] ['properties']['productInformation']['cloudCover'])\n",
                        "       # print (pyresult['features'][i] ['properties']['productInformation']['cloudCover'])\n",
                        "      except KeyError:\n",
                        "        pass\n",
                        "  fgNbr=fgNbr+1\n",
                        "  df = pd.DataFrame({getFigureLabel(fgNbr,\"Frequency plot of the cloud cover % for \" + platform )+' \\n \\n cloudPct': cloudCvPctVt}) \n",
                        "  hist = df.hist(bins=100)\n",
                        "  display(widgets.HTML(value='<br>'))\n",
                        "  \n",
                        "  return fgNbr\n",
                        "\n",
                        "#generateHist(fgNbr,'Sentinel-2')\n",
                        "#@title Generate Delivery Control Report\n",
                        "def generate_delivery_control_report(platform):\n",
                        "  \n",
                        "  def fillReportTable(processingLevel, deliveryControlMetric,table):\n",
                        "    col=getProcessingLevelIndex(processingLevel)\n",
                        "    if (col != -1):\n",
                        "      if deliveryControlMetric['complete']:\n",
                        "        table[0][col]=table[0][col]+1\n",
                        "      else:\n",
                        "        table[1][col]=table[1][col]+1\n",
                        "      if (deliveryControlMetric['status'] == \"WAITING\"):\n",
                        "        table[2][col]=table[2][col]+1\n",
                        "      elif (deliveryControlMetric['status'] == \"IN_PROGRESS\"):\n",
                        "        table[3][col]=table[3][col]+1\n",
                        "    else:\n",
                        "      print('processingLevel ' + processingLevel)\n",
                        "  \n",
                        "  def completeReportTable(table):\n",
                        "    for i in range(len(table)):\n",
                        "      nbcol=len(table[i])-1     \n",
                        "      for j in range(nbcol):    \n",
                        "        table[i][nbcol]=table[i][nbcol]+table[i][j]\n",
                        "  table_title = ['L1','L1TP','L1GT','L2A', 'L2 Processor', 'Total']\n",
                        "  table_index = ['TRUE','FALSE', 'WAITING', 'IN_PROGRESS']\n",
                        "  metric=\"http://qcmms.esa.int/quality-indicators/#deliveryControlMetric\"\n",
                        "\n",
                        "  table_report=[ [0]*6 for i in range(4)]\n",
                        "  querystring={}\n",
                        "  querystring['maximumRecords'] = maxRecords\n",
                        "  totalResults=1\n",
                        "  startIndex=1\n",
                        "  while (startIndex<=totalResults):\n",
                        "    querystring['startRecord'] = startIndex\n",
                        "    querystring['platform'] = platform\n",
                        "    response = requests.get(ipUrl, params=querystring)\n",
                        "    pyresult= json.loads(response.text)\n",
                        "    lenFeatures= len(pyresult['features'])\n",
                        "    startIndex=startIndex+maxRecords\n",
                        "    totalResults=pyresult['totalResults']\n",
                        "    for i in range(lenFeatures):\n",
                        "      #print(pyresult['features'][i] ['properties']['identifier'] )\n",
                        "      processingLevel=pyresult['features'][i]['properties']['productInformation']['processingLevel']        \n",
                        "      deliveryControlMetric=getMetric(metric,pyresult['features'][i])\n",
                        "      if (deliveryControlMetric != {}):\n",
                        "        fillReportTable(processingLevel, deliveryControlMetric, table_report)\n",
                        "  completeReportTable(table_report)\n",
                        "  pd_report = pd.DataFrame(table_report ,index = table_index, columns = table_title)\n",
                        "  display(pd_report)   \n",
                        "  display(widgets.HTML(value='<br>')) \n",
                        "#generate_delivery_control_report('LANDSAT-8')\n",
                        "#generate_delivery_control_report('Sentinel-2')\n",
                        "#@title Generate Ordinary Control Report\n",
                        "def generate_ordinary_control_report(platform):\n",
                        "  \n",
                        "  def initTableReport():\n",
                        "    table=[ [\"FALSE\",0,0,0,0,0] for i in range(len(procLevelDefs)*2)]\n",
                        "    for i in range(len(procLevelDefs)):\n",
                        "      table[i*2][0]=\"TRUE\"\n",
                        "    return table\n",
                        "  \n",
                        "  def getAttribute(attribute, metric):\n",
                        "    result={'present' : True,'value':True}\n",
                        "    try:\n",
                        "      result['value']=metric[attribute]\n",
                        "    except KeyError:\n",
                        "      result['present'] = False\n",
                        "    return result\n",
                        "  \n",
                        "  def getMetricValue(metricValue):\n",
                        "    result={'present' : True,'value':True}\n",
                        "    try:\n",
                        "      result['value']=metricValue\n",
                        "    except KeyError:\n",
                        "      result['present'] = False\n",
                        "    return result\n",
                        "\n",
                        "  def getRaster(ordinaryControlMetric):\n",
                        "    result={}\n",
                        "    try:\n",
                        "      result=ordinaryControlMetric['harmonized']['tile'][0]['raster']\n",
                        "    except KeyError:\n",
                        "      pass\n",
                        "    return result\n",
                        "\n",
                        "\n",
                        "  def fillReportByLevel(level,ordinaryControlMetric):\n",
                        "    try:\n",
                        "      # compute table from rastsers complete to end\n",
                        "      table_row=[{'present' : False,'value':True},\n",
                        "                 {'present' : False,'value':True},\n",
                        "                 {'present' : False,'value':True},\n",
                        "                 {'present' : False,'value':True},\n",
                        "                 {'present' : False,'value':True},\n",
                        "                 {'present' : False,'value':True}]\n",
                        "      # prepare working row to avoid list of if else for all columns\n",
                        "      if (level=='harmonized'):\n",
                        "        raster=getRaster(ordinaryControlMetric)\n",
                        "        if (raster != {}):\n",
                        "          table_row[0] = getAttribute('rastersComplete', raster) \n",
                        "          table_row[1] = getAttribute('rastersRead', raster)     \n",
                        "          table_row[2] = getAttribute('calibrationMetadata', raster)     \n",
                        "          table_row[3] = getAttribute('metadataRead', raster)  \n",
                        "          table_row[4] = getMetricValue(ordinaryControlMetric['value']) \n",
                        "      else:\n",
                        "        table_row[0] = getAttribute('rastersComplete', ordinaryControlMetric[level]) \n",
                        "        table_row[1] = getAttribute('rastersRead', ordinaryControlMetric[level])     \n",
                        "        table_row[2] = getAttribute('calibrationMetadata', ordinaryControlMetric[level])     \n",
                        "        table_row[3] = getAttribute('metadataRead', ordinaryControlMetric[level])  \n",
                        "        table_row[4] = getMetricValue(ordinaryControlMetric['value']) \n",
                        "  #    table_row[5] = getAttribute('rows', ordinaryControlMetric[level])\n",
                        "     \n",
                        "      #table_index=processingLevelIndex*2\n",
                        "      if (level=='level1'):\n",
                        "        table_index=0\n",
                        "      elif (level=='level2'):\n",
                        "        table_index=2\n",
                        "      else:\n",
                        "        table_index=4\n",
                        "      # for each columns, the row is determined by the processing level &\n",
                        "      # and boolean value of the corresponding attribute\n",
                        "      # the second column has already been filled by the table initialisation\n",
                        "      # note that the titles and first column are not part of the table\n",
                        "      # are passed at the dataframe construction\n",
                        "\n",
                        "      # for each column\n",
                        "      for i in range(len(table_row)):\n",
                        "        if (table_row[i]['present']):\n",
                        "          # compute table index = table row nbr\n",
                        "          # second line of boolean is false \n",
                        "          if (table_row[i]['value']):\n",
                        "            ti = table_index\n",
                        "          else:\n",
                        "            ti = table_index+1\n",
                        "          # compute table column, first columns is fixed.\n",
                        "          tc=i+1 \n",
                        "          table_report[ti][tc]=table_report[ti][tc]+1\n",
                        "    except KeyError:\n",
                        "      pass\n",
                        "\n",
                        "  def fillReportTable(processingLevel, ordinaryControlMetric):\n",
                        "    processingLevelIndex=getProcessingLevelIndex(processingLevel)\n",
                        "    #print(\"level \",processingLevel, \"index \",processingLevelIndex)\n",
                        "    if (processingLevelIndex != -1):\n",
                        "      fillReportByLevel('level1',ordinaryControlMetric)\n",
                        "      fillReportByLevel('level2',ordinaryControlMetric)\n",
                        "      if harmonized():\n",
                        "         fillReportByLevel('harmonized',ordinaryControlMetric)\n",
                        "  \n",
                        "  procLevelDefs=['L1', 'L2']\n",
                        "  table_index = [procLevelDefs[0],'', procLevelDefs[1],'']\n",
                        "  if harmonized():    \n",
                        "    procLevelDefs=['L1', 'L2','LH'] \n",
                        "    table_index = [procLevelDefs[0],'', procLevelDefs[1],'', procLevelDefs[2],'']\n",
                        "  \n",
                        "  table_title = ['Eval.','Rasters complete', 'Rasters read', 'Calibration metadata', 'Metadata read','Total' ]\n",
                        "  \n",
                        "\n",
                        "  \n",
                        "  metric=\"http://qcmms.esa.int/quality-indicators/#ordinaryControlMetric\"\n",
                        "\n",
                        "  table_report=initTableReport()  \n",
                        "  querystring={}\n",
                        "  querystring['maximumRecords'] = maxRecords\n",
                        "  querystring['platform'] = platform\n",
                        "  totalResults=1\n",
                        "  startIndex=1\n",
                        "  while (startIndex<=totalResults):\n",
                        "    querystring['startRecord'] = startIndex\n",
                        "    response = requests.get(ipUrl, params=querystring)\n",
                        "    pyresult= json.loads(response.text)\n",
                        "    lenFeatures= len(pyresult['features'])\n",
                        "    startIndex=startIndex+maxRecords\n",
                        "    totalResults=pyresult['totalResults']\n",
                        "    for i in range(lenFeatures):\n",
                        "      processingLevel=pyresult['features'][i]['properties']['productInformation']['processingLevel']\n",
                        "      ordinaryControlMetric=getMetric(metric,pyresult['features'][i])\n",
                        "      if (ordinaryControlMetric != {}):\n",
                        "        fillReportTable(processingLevel, ordinaryControlMetric)\n",
                        "  #print(\"end report\")\n",
                        "  \n",
                        "  pd_report = pd.DataFrame(table_report ,index = table_index, columns = table_title)\n",
                        "  display(pd_report)\n",
                        "  display(widgets.HTML(value='<br>'))\n",
                        "#generate_ordinary_control_report(\"LANDSAT-8\")\n",
                        "#generate_ordinary_control_report(\"Sentinel-2\")\n",
                        "#@title Generate Detailed Control Report\n",
                        "def generate_detailed_control_report(platform):\n",
                        "  \n",
                        "  def fillReportTableCell(tc,detailedControlMetric, attributeName, metricId):\n",
                        "    ti=1\n",
                        "    try:\n",
                        "      vect=detailedControlMetric[attributeName]\n",
                        "      for i in range(len(vect)):\n",
                        "        if ( (vect[i][\"id\"]==metricId) and (vect[i][\"mask\"]!=\"\" )):\n",
                        "          ti=0\n",
                        "    except KeyError:\n",
                        "      pass\n",
                        "    table_report[ti][tc]=table_report[ti][tc]+1\n",
                        "    #print(ti, tc, table_report[ti][tc] )\n",
                        "\n",
                        "  def fillReportTableLastCell(tc,detailedControlMetric):\n",
                        "    ti=1\n",
                        "    try:\n",
                        "      if (detailedControlMetric['value']):\n",
                        "        ti=0\n",
                        "    except KeyError:\n",
                        "      pass\n",
                        "    table_report[ti][tc]=table_report[ti][tc]+1\n",
                        "    #print(ti, tc, table_report[ti][tc] )\n",
                        "\n",
                        "  def fillReportTable(detailedControlMetric):\n",
                        "    fillReportTableCell(0,detailedControlMetric, \"cloudCover\", \"http://qcmms.esa.int/detailed_control#CLOUD_COVER\")\n",
                        "    fillReportTableCell(1,detailedControlMetric, \"cloudCover\", \"http://qcmms.esa.int/detailed_control#ALTERNATE_CLOUD_COVER\")\n",
                        "    fillReportTableCell(2,detailedControlMetric, \"geometry\", \"http://qcmms.esa.int/detailed_control#GEOMETRY\")\n",
                        "    fillReportTableCell(3,detailedControlMetric, \"validPixels\", \"http://qcmms.esa.int/detailed_control#VALID_PIXELS\")\n",
                        "    fillReportTableLastCell(4,detailedControlMetric)\n",
                        "\n",
                        "  table_title = ['Cloud cover layer','Cloud cover alternative layer', 'Geometry val.layer', 'Valid pixel metadata', 'TOTAL' ]\n",
                        "  table_index = ['TRUE','FALSE']\n",
                        "  metric=\"http://qcmms.esa.int/quality-indicators/#detailedControlMetric\"\n",
                        "  table_report=[ [0,0,0,0,0],  [0,0,0,0,0]]  \n",
                        "\n",
                        "  querystring={}\n",
                        "  querystring['maximumRecords'] = maxRecords\n",
                        "  querystring['platform'] = platform\n",
                        "  totalResults=1\n",
                        "  startIndex=1\n",
                        "  while (startIndex<=totalResults):\n",
                        "    querystring['startRecord'] = startIndex   \n",
                        "    response = requests.get(ipUrl, params=querystring)\n",
                        "    pyresult= json.loads(response.text)\n",
                        "    lenFeatures= len(pyresult['features'])\n",
                        "    startIndex=startIndex+maxRecords\n",
                        "    totalResults=pyresult['totalResults']\n",
                        "    for i in range(lenFeatures):\n",
                        "      detailedControlMetric=getMetric(metric,pyresult['features'][i])\n",
                        "      if (detailedControlMetric != {}):\n",
                        "        fillReportTable(detailedControlMetric)\n",
                        "  pd_report = pd.DataFrame(table_report ,index = table_index, columns = table_title)\n",
                        "  display(pd_report)   \n",
                        "  \n",
                        "  display(widgets.HTML(value='<br>'))\n",
                        "#generate_detailed_control_report()\n",
                        "#@title Generate Detailed Control Stat Report\n",
                        "def generate_detailed_control_stat_report(platform):\n",
                        "  \n",
                        "  def fillReportTableCell(tc,detailedControlMetric, attributeName1,attributeName2,metricId):\n",
                        "    \n",
                        "    try:\n",
                        "      vect=detailedControlMetric[attributeName1]\n",
                        "      for i in range(len(vect)):\n",
                        "        if (vect[i][\"id\"]==metricId):\n",
                        "          table_report[tc]=table_report[tc]+vect[i][attributeName2]\n",
                        "          table_number[tc]=table_number[tc]+1\n",
                        "    except KeyError:\n",
                        "      pass\n",
                        "\n",
                        "  def fillReportTableCellDiff(tc,detailedControlMetric,attributeName1, attributeName2,  metricId,diffMaxLimit):\n",
                        "    try:\n",
                        "      vect=detailedControlMetric[attributeName1]\n",
                        "      for i in range(len(vect)):\n",
                        "        if (vect[i][\"id\"]==metricId):\n",
                        "          if vect[i][attributeName2] > diffMaxLimit:\n",
                        "            table_report[tc]=table_report[tc]+1          \n",
                        "    except KeyError:\n",
                        "      pass\n",
                        "\n",
                        "  def computeMean():\n",
                        "    for i in range(len(table_number)):\n",
                        "      if (table_number[i] != 0):\n",
                        "        table_report[i] = table_report[i] / table_number[i]\n",
                        "\n",
                        "  def fillReportTable(detailedControlMetric):\n",
                        "    fillReportTableCell(0,detailedControlMetric, \"cloudCover\",  \"cloudPct\", \"http://qcmms.esa.int/detailed_control#CLOUD_COVER\")\n",
                        "    fillReportTableCell(1,detailedControlMetric, \"cloudCover\",  \"cloudPct\", \"http://qcmms.esa.int/detailed_control#ALTERNATE_CLOUD_COVER\")\n",
                        "    fillReportTableCell(2,detailedControlMetric, \"geometry\",    \"rmseX\",    \"http://qcmms.esa.int/detailed_control#GEOMETRY\")\n",
                        "    fillReportTableCell(3,detailedControlMetric, \"geometry\",    \"rmseY\",    \"http://qcmms.esa.int/detailed_control#GEOMETRY\")\n",
                        "    fillReportTableCell(6,detailedControlMetric, \"validPixels\", \"validPct\",  \"http://qcmms.esa.int/detailed_control#VALID_PIXELS\")\n",
                        "    fillReportTableCellDiff(4,detailedControlMetric, \"geometry\", \"diffXmax\",  \"http://qcmms.esa.int/detailed_control#GEOMETRY\",diffMaxLimit)\n",
                        "    fillReportTableCellDiff(5,detailedControlMetric, \"geometry\", \"diffYmax\",  \"http://qcmms.esa.int/detailed_control#GEOMETRY\",diffMaxLimit)\n",
                        "    \n",
                        "  diffMaxLimit = geometric_resolution / 2 \n",
                        "  dmlstr=str(diffMaxLimit)\n",
                        "  table_index = ['']\n",
                        "  table_title = ['Mean\\\\nCloud cover','Mean\\\\nCloud alternative', 'Mean\\\\nGeometry RmseX', 'Mean\\\\nGeometry RmseY','Nb > '+ dmlstr +'\\\\nGeometry Diffx Max', 'Nb > '+ dmlstr +'\\\\nDiffy Max' ,'Mean\\\\nValid Pixels' ]\n",
                        "  table_number =[   0,               0,                 0,                 0,                1,                1,           0]  # used to compute mean when required.\n",
                        "  metric=\"http://qcmms.esa.int/quality-indicators/#detailedControlMetric\"\n",
                        "  \n",
                        "  table_report=[0,0,0,0,0,0,0]  \n",
                        "  querystring={}\n",
                        "  querystring['maximumRecords'] = maxRecords\n",
                        "  querystring['platform'] = platform\n",
                        "  totalResults=1\n",
                        "  startIndex=1\n",
                        "  while (startIndex<=totalResults):\n",
                        "    querystring['startRecord'] = startIndex\n",
                        "    response = requests.get(ipUrl, params=querystring)\n",
                        "    pyresult= json.loads(response.text)\n",
                        "    lenFeatures= len(pyresult['features'])\n",
                        "    startIndex=startIndex+maxRecords\n",
                        "    totalResults=pyresult['totalResults']\n",
                        "    for i in range(lenFeatures):\n",
                        "      detailedControlMetric=getMetric(metric,pyresult['features'][i])\n",
                        "      if (detailedControlMetric != {}):\n",
                        "        fillReportTable(detailedControlMetric)\n",
                        "  computeMean()\n",
                        "  table_report2=[table_report]\n",
                        "  pd_report = pd.DataFrame(table_report2,index = table_index, columns = table_title)\n",
                        "  #display(pd_report)  \n",
                        "  pretty_print(pd_report,'')\n",
                        "  display(widgets.HTML(value='<br>')) \n",
                        "# generate_detailed_control_stat_report()\n",
                        "#@title Plot CE\n",
                        "def generate_Plot_CE(fgNbr,platform):\n",
                        "\n",
                        "  def computeCircularError(percentile):\n",
                        "    # compute the index in the sorted array to have the required percentage (percentile)  of points inside the circle of center 0,0 and radius = that distance \n",
                        "    index=math.ceil((pd_report.size/3)*(percentile/100.0))\n",
                        "    # return the computed distance (column=2) \n",
                        "    return pd_report.iat[index-1,2]\n",
                        "\n",
                        "  def plotCE(ce,title):\n",
                        "    x_vec=pd_report['diffXmax'].values.tolist()\n",
                        "    y_vec=pd_report['diffYmax'].values.tolist()\n",
                        "     \n",
                        "    if (( len(x_vec)==0 ) or ( len(y_vec)==0 )):\n",
                        "      print(\"no data available for the plot (diff Xmax, diff Ymax)\")\n",
                        "    else:\n",
                        "      plt.scatter(x_vec,y_vec)\n",
                        "      fig=plt.gcf()\n",
                        "      ax=fig.gca()\n",
                        "      ax.axis('equal')\n",
                        "      #plt.ioff()\n",
                        "      #plt.hold(False)\n",
                        "      #print(\"interactive \",plt.isinteractive())\n",
                        "      title=title+' \\n\\n ' + 'CE'+str(percentile) + \" = \" + str(round(ce,1))\n",
                        "      plt.title(title) \n",
                        "      #  plt.title(title + ' \n",
                        "      #  CE'+str(percentile) + \" = \" + str(round(ce,1)))\n",
                        "      plt.xlabel(\"x-offset\")\n",
                        "      plt.ylabel(\"y-offset\")\n",
                        "      ce_circle=plt.Circle((0,0),ce,edgecolor='r',fill=False)\n",
                        "      ax.add_artist(ce_circle)\n",
                        "      plt.show()\n",
                        "\n",
                        "  def distFromOrigin(xMax,yMax):\n",
                        "    return math.sqrt(xMax*xMax+yMax*yMax)\n",
                        "  \n",
                        "  def fillReportTableCell(detailedControlMetric,attributeName,  metricId,dataAvailable):\n",
                        "    try:\n",
                        "      vect=detailedControlMetric[attributeName]\n",
                        "      for i in range(len(vect)):\n",
                        "        if (vect[i][\"id\"]==metricId):\n",
                        "          xMax=vect[i]['diffXmax']\n",
                        "          yMax=vect[i]['diffYmax']\n",
                        "          dist=distFromOrigin(xMax,yMax)\n",
                        "          table_report.append([xMax,yMax,dist])\n",
                        "          dataAvailable=True\n",
                        "        \n",
                        "    except KeyError:\n",
                        "      pass\n",
                        "    return dataAvailable\n",
                        "\n",
                        "  def fillReportTable(detailedControlMetric,dataAvailable):\n",
                        "    return fillReportTableCell(detailedControlMetric, \"geometry\", \"http://qcmms.esa.int/detailed_control#GEOMETRY\",dataAvailable)\n",
                        "     \n",
                        "  metric=\"http://qcmms.esa.int/quality-indicators/#detailedControlMetric\"  \n",
                        "  querystring={}\n",
                        "  querystring['maximumRecords'] = maxRecords\n",
                        "  querystring['platform'] = platform\n",
                        "  totalResults=1\n",
                        "  startIndex=1\n",
                        "  table_report=[]\n",
                        "  table_column=['diffXmax','diffYmax','distance']\n",
                        "  percentile=90\n",
                        "  dataAvailable = False\n",
                        "  while (startIndex<=totalResults):\n",
                        "    querystring['startRecord'] = startIndex\n",
                        "    \n",
                        "    response = requests.get(ipUrl, params=querystring)\n",
                        "    pyresult= json.loads(response.text)\n",
                        "    lenFeatures= len(pyresult['features'])\n",
                        "   \n",
                        "    \n",
                        "    startIndex=startIndex+maxRecords\n",
                        "    totalResults=pyresult['totalResults']\n",
                        "    if(lenFeatures > 0):\n",
                        "       for i in range(lenFeatures):\n",
                        "          detailedControlMetric=getMetric(metric,pyresult['features'][i])           \n",
                        "          dataAvailable=fillReportTable(detailedControlMetric, dataAvailable)\n",
                        "  if(dataAvailable):\n",
                        "     pd_report = pd.DataFrame(table_report,columns=table_column)\n",
                        "     pd_report.sort_values([\"distance\"],axis=0,ascending=[True],inplace=True)\n",
                        "     #display(pd_report)\n",
                        "     fgNbr=fgNbr+1\n",
                        "     gr_str=str(geometric_resolution)\n",
                        "     title=getFigureLabel(fgNbr,\"Geometry validation results, requirement: geometry quality < 0.5 pixel of \"+ gr_str +\" m for \" + platform )\n",
                        "     circularError=computeCircularError(percentile)\n",
                        "     plotCE(circularError, title)\n",
                        "     #pd_report.plot.scatter(x='diffXmax',y='diffYmax') \n",
                        "  else:\n",
                        "    print(\"No data available for this plot.\")\n",
                        "  return fgNbr  \n",
                        "#generate_Plot_CE(0 ,'LANDSAT-8')\n",
                        "\n",
                        "def generate_radiometryConsistency_control_report(platform):\n",
                        "#------------------------------------------------------------------------------------\n",
                        "  def fillReportTableCell(tc,detailedControlMetric, attributeName1,attributeName2,metricId):\n",
                        "    \n",
                        "    try:\n",
                        "      vect=detailedControlMetric[attributeName1]\n",
                        "      for i in range(len(vect)):\n",
                        "        if (vect[i][\"id\"]==metricId):\n",
                        "          table_report[tc]=table_report[tc]+vect[i][attributeName2]\n",
                        "          table_number[tc]=table_number[tc]+1\n",
                        "    except KeyError:\n",
                        "      pass\n",
                        "\n",
                        "  \n",
                        "\n",
                        "  def computeMean():\n",
                        "    for i in range(len(table_number)):\n",
                        "      if (table_number[i] != 0):\n",
                        "        table_report[i] = table_report[i] / table_number[i]\n",
                        "\n",
                        "  def fillReportTable(detailedControlMetric):\n",
                        "    fillReportTableCell(0,detailedControlMetric, \"cloudCover\",  \"cloudPct\", \"http://qcmms.esa.int/detailed_control#CLOUD_COVER\")\n",
                        "    fillReportTableCell(1,detailedControlMetric, \"cloudCover\",  \"cloudPct\", \"http://qcmms.esa.int/detailed_control#ALTERNATE_CLOUD_COVER\")\n",
                        "    fillReportTableCell(2,detailedControlMetric, \"geometry\",    \"rmseX\",    \"http://qcmms.esa.int/detailed_control#GEOMETRY\")\n",
                        "    fillReportTableCell(3,detailedControlMetric, \"geometry\",    \"rmseY\",    \"http://qcmms.esa.int/detailed_control#GEOMETRY\")\n",
                        "    fillReportTableCell(6,detailedControlMetric, \"validPixels\", \"validPct\",  \"http://qcmms.esa.int/detailed_control#VALID_PIXELS\")\n",
                        "    fillReportTableCellDiff(4,detailedControlMetric, \"geometry\", \"diffXmax\",  \"http://qcmms.esa.int/detailed_control#GEOMETRY\",diffMaxLimit)\n",
                        "    fillReportTableCellDiff(5,detailedControlMetric, \"geometry\", \"diffYmax\",  \"http://qcmms.esa.int/detailed_control#GEOMETRY\",diffMaxLimit)\n",
                        "    \n",
                        "  table_index = ['']\n",
                        "  table_title = ['Mean\\\\nCloud cover','Mean\\\\nCloud alternative', 'Mean\\\\nGeometry RmseX', 'Mean\\\\nGeometry RmseY','Nb > 5\\\\nGeometry DiffX Max', 'Nb > 5\\\\nDiffY Max' ,'Mean\\\\nValid Pixels' ]\n",
                        "  table_number =[   0,               0,                 0,                 0,                1,                1,           0]  # used to compute mean when required.\n",
                        "  metric=\"http://qcmms.esa.int/quality-indicators/#harmonizationControlMetric\"\n",
                        "  \n",
                        "  table_report=[0,0,0,0,0,0,0]  \n",
                        "  querystring={}\n",
                        "  querystring['maximumRecords'] = maxRecords\n",
                        "  querystring['platform'] = platform\n",
                        "  totalResults=1\n",
                        "  startIndex=1\n",
                        "  while (startIndex<=totalResults):\n",
                        "    querystring['startRecord'] = startIndex\n",
                        "    response = requests.get(ipUrl, params=querystring)\n",
                        "    pyresult= json.loads(response.text)\n",
                        "    lenFeatures= len(pyresult['features'])\n",
                        "    startIndex=startIndex+maxRecords\n",
                        "    totalResults=pyresult['totalResults']\n",
                        "    for i in range(lenFeatures):\n",
                        "      radiometryConsistencyControlMetric=getMetric(metric,pyresult['features'][i])\n",
                        "      if (detailedControlMetric != {}):\n",
                        "        fillReportTable(detailedControlMetric)\n",
                        "  computeMean()\n",
                        "  table_report2=[table_report]\n",
                        "  pd_report = pd.DataFrame(table_report2,index = table_index, columns = table_title)\n",
                        "  #display(pd_report)  \n",
                        "  pretty_print(pd_report,'')\n",
                        "  display(widgets.HTML(value='<br>')) \n",
                        "#------------------------------------------------------------------------------------\n",
                        "\n",
                        "def displayRadiometryConsistencyBarchart(fgNbr,platform):\n",
                        "  \n",
                        "  nbStat=3\n",
                        "  \n",
                        "  StatTable={}\n",
                        "  References=[]\n",
                        "  def fillMin(value,var):\n",
                        "    if value < var:\n",
                        "      var=value\n",
                        "    return var\n",
                        "\n",
                        "  def fillMax(value,var):\n",
                        "    if value > var:\n",
                        "      var=value\n",
                        "    return var\n",
                        "  \n",
                        "  def fillMean(value,var):\n",
                        "    var=value+var\n",
                        "    return var\n",
                        "   \n",
                        "          \n",
                        "  def computeMean():\n",
                        "    for i in range(len(References)):\n",
                        "      for bd in  StatTable[References[i]['category']]:\n",
                        "        StatTable[References[i]['category']] [bd] ['Mean'] =StatTable[References[i]['category']] [bd] ['Mean'] / StatTable[References[i]['category']] [bd] ['Nb']\n",
                        "\n",
                        "  def  fillStatTable(firstRecord,radiometryConsistencyControlMetric,References):\n",
                        "    bandsTempConsistency=radiometryConsistencyControlMetric['radiometryConsistency'][0]['bandsTemporalConsistency']\n",
                        "    if firstRecord:\n",
                        "      References=radiometryConsistencyControlMetric['radiometryConsistency'][0]['references']\n",
                        "      for i in range(len(References)): \n",
                        "        StatTable[References[i]['category']]={}\n",
                        "        \n",
                        "        for j in range(len(bandsTempConsistency)): \n",
                        "          StatTable[References[i]['category']][bandsTempConsistency[j]['id'] ]={}\n",
                        "          StatTable[References[i]['category']][bandsTempConsistency[j]['id'] ]['Min']=999999          \n",
                        "          StatTable[References[i]['category']][bandsTempConsistency[j]['id'] ]['Max']=-999999\n",
                        "          StatTable[References[i]['category']][bandsTempConsistency[j]['id'] ]['Mean']=0\n",
                        "          StatTable[References[i]['category']][bandsTempConsistency[j]['id'] ]['Nb']=0\n",
                        "\n",
                        "    for j in range(len(bandsTempConsistency)):\n",
                        "       for i in range(len(References)):\n",
                        "         value=bandsTempConsistency[j][References[i]['category']]\n",
                        "         bd=bandsTempConsistency[j]['id']\n",
                        "         StatTable[References[i]['category']][bd] ['Min']=fillMin(value, StatTable[References[i]['category']][bd] ['Min'])\n",
                        "         StatTable[References[i]['category']][bd] ['Max']=fillMax(value, StatTable[References[i]['category']][bd] ['Max'])\n",
                        "         StatTable[References[i]['category']][bd] ['Mean']=fillMean(value,StatTable[References[i]['category']][bd] ['Mean'])\n",
                        "         StatTable[References[i]['category']][bd] ['Nb']= StatTable[References[i]['category']][bd] ['Nb']+1\n",
                        "\n",
                        "    return References\n",
                        "       \n",
                        "\n",
                        "  def cvtStatTableToBarChart(ref,figureLabel):\n",
                        "    nbBand=len(StatTable[ref])\n",
                        "    i=0\n",
                        "    vt=[{}]*nbBand*nbStat\n",
                        "    for bd in StatTable[ref]:\n",
                        "      for stat in StatTable[ref][bd]:\n",
                        "        if stat != 'Nb':\n",
                        "          vt[i]={figureLabel :bd,  'Stat' : stat , 'Value' : StatTable[ref][bd][stat]}\n",
                        "          i=i+1\n",
                        "    return vt\n",
                        "#-------------------------------------\n",
                        "  querystring={}\n",
                        "  querystring['maximumRecords'] = maxRecords\n",
                        "  querystring['platform'] = platform\n",
                        "  metric=\"http://qcmms.esa.int/quality-indicators/#harmonizationControlMetric\"\n",
                        "  totalResults=1\n",
                        "  startIndex=1\n",
                        "  firstRecord=True\n",
                        "  while (startIndex<=totalResults):\n",
                        "    querystring['startRecord'] = startIndex\n",
                        "    response = requests.get(ipUrl, params=querystring)\n",
                        "    pyresult= json.loads(response.text)\n",
                        "    lenFeatures= len(pyresult['features'])\n",
                        "    startIndex=startIndex+maxRecords\n",
                        "    totalResults=pyresult['totalResults']\n",
                        "    for i in range(lenFeatures):\n",
                        "      radiometryConsistencyControlMetric=getMetric(metric,pyresult['features'][i])\n",
                        "      if (radiometryConsistencyControlMetric != {}):\n",
                        "          References=fillStatTable(firstRecord,radiometryConsistencyControlMetric,References)\n",
                        "          firstRecord=False\n",
                        "         \n",
                        "  computeMean()\n",
                        "  for i in range(len(References)):\n",
                        "    fgNbr = fgNbr+1\n",
                        "    figureLabel=\"Figure \"+ str(fgNbr) + \" : Temporal Consistency for \"+ platform +\" and reference \" + References[i]['category']\n",
                        "    vt=cvtStatTableToBarChart(References[i]['category'],figureLabel)                \n",
                        "    df = pd.DataFrame(vt)\n",
                        "    df.groupby([figureLabel,'Stat']).sum().unstack().plot(kind='bar') \n",
                        "  return {\"fgNbr\":fgNbr,\"references\":References}\n",
                        "#displayRadiometryConsistencyBarchart(1,\"Sentinel-2\")\n",
                        "\n",
                        "#------------------------------------------------------------------------------------\n",
                        "\n",
                        "\n",
                        "#@title Fit-for-Purpose\n",
                        "def getFitForPurpose(fgNbr):\n",
                        "  lpMd=getLandProduct()\n",
                        "  if(lpMd != {}):\n",
                        "    metric=getMetric(\"http://qcmms.esa.int/quality-indicators/#ipForLpInformationMetric\",lpMd)\n",
                        "    print(\"The status of the spatial coverage analysis is :\" ,metric['fitnessForPurpose'] )\n",
                        "    display(widgets.HTML(value='<br>'))\n",
                        "   \n",
                        "    for year in sorted(metric['vpxCoverage'].keys()):\n",
                        "      image=metric['vpxCoverage'][year]['mask']\n",
                        "      displayImage(image)\n",
                        "      fgNbr=generateFigureLabel(fgNbr,\"Fit For Purpose mask year \" + year)\n",
                        "      print(\"Additional information on the valid pixels coverage:\")\n",
                        "      print(\"   - Min: \",metric['vpxCoverage'][year]['min'])\n",
                        "      print(\"   - Max: \",metric['vpxCoverage'][year]['max'])\n",
                        "      print(\"   - Gap percentage: \", metric['vpxCoverage'][year]['gapPct'])\n",
                        "\n",
                        "  return fgNbr\n",
                        "    #print (image)\n",
                        "    #  for att in dir(metric['vpxCoverage']):\n",
                        "    #  print (att, getattr(metric['vpxCoverage'],att))\n",
                        "#@title Production Quality Indicators\n",
                        "def generate_production_and_validation_quality_indicators_report(metricId):\n",
                        " \n",
                        "  lpMd=getLandProduct()\n",
                        "  if(lpMd != {}):\n",
                        "    metric=getMetric(metricId,lpMd)\n",
                        "    \n",
                        "    if (metric != {}):\n",
                        "      try:\n",
                        "        # urban_index=metric['classification']['codingClasses']['urban']\n",
                        "        # non_urban_index=metric['classification']['codingClasses']['non-urban']\n",
                        "        nb_classes=len(metric['classification']['codingClasses'])\n",
                        "       \n",
                        "        table_index = [''] * nb_classes\n",
                        "        table_title=[''] * (nb_classes+1)\n",
                        "       \n",
                        "        table_title[0]='Class / \\\\nIndicator'\n",
                        "   \n",
                        "        for i in range(nb_classes):\n",
                        "          table_title[i+1]='\\\\n'+metric['classification']['codingClasses'][i]\n",
                        "        middle_col=nb_classes//2+1\n",
                        "        table_title[middle_col]='REFERENCE'+table_title[middle_col]\n",
                        "        table_report=[ [0]*len(table_title) for i in range(nb_classes)]\n",
                        "      except KeyError:\n",
                        "         pass\n",
                        "      \n",
                        "      try:\n",
                        "        confusionMatrix=metric['classification']['confusionMatrix']\n",
                        "        for i in range(nb_classes):\n",
                        "          table_report[i][0]=metric['classification']['codingClasses'][i]\n",
                        "          for j in range (nb_classes):\n",
                        "            table_report[i][j+1]=confusionMatrix[i][j] \n",
                        "        pd_report = pd.DataFrame(table_report ,index = table_index, columns = table_title)       \n",
                        "        pretty_print(pd_report,'')\n",
                        "        display(widgets.HTML(value='<br><br>'))\n",
                        "      except KeyError:\n",
                        "        pass  \n",
                        "      \n",
                        " \n",
                        " #    display other parameters\n",
                        " #\n",
                        "      try:\n",
                        "        table_report=[\n",
                        "        ['Kappa',             getClassificationAttribute(metric['classification'],'kappa')],\n",
                        "        ['Overall Accuracy',  getClassificationAttribute(metric['classification'],'overallAccuracy')],   \n",
                        "        ['Producers Accuracy',getClassificationAttribute(metric['classification'],'producersAccuracy')],\n",
                        "        ['Users Accuracy',    getClassificationAttribute(metric['classification'],'usersAccuracy')]             \n",
                        "        ]\n",
                        "        table_index = ['','','','']\n",
                        "        table_title =['Other Parameters','Value']\n",
                        "        pd_report = pd.DataFrame(table_report , index=table_index,columns = table_title)\n",
                        "        display(pd_report)\n",
                        "      except KeyError:\n",
                        "        pass \n",
                        "\n",
                        "      try:\n",
                        "        displayValidationObject(\"Seasonality\",metric['seasonality'] )\n",
                        "      except KeyError:\n",
                        "        pass\n",
                        "\n",
                        "      try:\n",
                        "        displayValidationObject(\"Density Cover\",metric['densityCover'] )\n",
                        "      except KeyError:\n",
                        "        pass\n",
                        "\n",
                        "\n",
                        "def displayValidationObject(title, theObject):\n",
                        "  try:\n",
                        "    table_report=[\n",
                        "                ['MAE',       theObject['mae']],\n",
                        "                ['RMSE',      theObject['rmse']], \n",
                        "                ['MSE',       theObject['mse']],\n",
                        "                ['PerseonR',  theObject['pearsonR']],\n",
                        "                ['Coding Values',  toStringCodingValues(theObject['codingValues'])] \n",
                        "      ]\n",
                        "    table_index = ['','','','','']\n",
                        "    table_title =[title,'Value']\n",
                        "    pd_report = pd.DataFrame(table_report , index=table_index,columns = table_title)\n",
                        "    pretty_print(pd_report,'')\n",
                        "  except KeyError:\n",
                        "    pass\n",
                        "\n",
                        "def toStringCodingValues(codingValues):\n",
                        "  res=''\n",
                        "  for key in codingValues:\n",
                        "    res= res + key + \": \"+ toString(codingValues[key]) + \"\\\\n\"\n",
                        "  return res\n",
                        "\n",
                        "def  getMetricAttribute(metric,attribute):\n",
                        "  res=''\n",
                        "  try:\n",
                        "    res=metric[attribute]\n",
                        "  except KeyError:\n",
                        "    pass\n",
                        "  return res \n",
                        "\n",
                        "\n",
                        "def generate_metadata_control_report(): \n",
                        "  lpMd=getLandProduct()\n",
                        "  if(lpMd != {}):\n",
                        "    metric=getMetric(\"http://qcmms.esa.int/quality-indicators/#lpMetadataControlMetric\",lpMd)\n",
                        "    if (metric != {}):\n",
                        "      try:\n",
                        "        metadataAvailable=getMetricAttribute(metric,'metadataAvailable')\n",
                        "        metadataCompliancy=getMetricAttribute(metric,'metadataCompliancy')\n",
                        "        metadataSpecification=getMetricAttribute(metric,'metadataSpecification')\n",
                        "        if (metadataAvailable):\n",
                        "          print(\"Land product metadata are available.\")\n",
                        "          if metadataCompliancy:\n",
                        "            verb=\" are \"\n",
                        "          else:\n",
                        "            verb=\" are not \"\n",
                        "          print(\"Metadata\"+verb+ \"compliant with \"+metadataSpecification + \".\")\n",
                        "      except KeyError:\n",
                        "        pass  \n",
                        "def generate_product_ordinary_control_report():\n",
                        "  lpMd=getLandProduct()\n",
                        "  if(lpMd != {}):\n",
                        "    metric=getMetric(\"http://qcmms.esa.int/quality-indicators/#lpOrdinaryControlMetric\",lpMd)\n",
                        "    if (metric != {}):\n",
                        "      display(widgets.HTML(value='<br><br>'))\n",
                        "      table_report=[\n",
                        "          ['Lineage',      getMetricAttribute(metric,'lineage')],   \n",
                        "          ['Raster Format',getMetricAttribute(metric,'rasterFormat')],\n",
                        "          ['Readable',     getMetricAttribute(metric,'read')],\n",
                        "          ['Data Type',    getMetricAttribute(metric,'dataType')],\n",
                        "          ['EPSG',         getMetricAttribute(metric,'epsg')],\n",
                        "          ['Extent [ULX, ULY, LRX, LRY]',  getMetricAttribute(metric,'extentUlLr')], \n",
                        "          ['Pixel Resolution in X direction',str(getMetricAttribute(metric,'xRes'))+'m'],  \n",
                        "          ['Pixel Resolution in Y direction',str(getMetricAttribute(metric,'yRes'))+'m'],  \n",
                        "          ['AOI Coverage Percentage', str(getMetricAttribute(metric,'aoiCoveragePct'))+'%']     \n",
                        "         ]\n",
                        "      table_index = ['','','','','','','','','']\n",
                        "      table_title = ['Parameters','Value']\n",
                        "      pd_report = pd.DataFrame(table_report , index=table_index,columns = table_title)\n",
                        "      display(pd_report)\n",
                        "\n",
                        "def getClassificationAttribute(classification,attribute):\n",
                        "  res=''\n",
                        "  try:\n",
                        "      res=classification[attribute]\n",
                        "  except KeyError:\n",
                        "        pass\n",
                        "  return res \n",
                        "\n",
                        "\n",
                        "def pretty_print(df, align):\n",
                        "  \n",
                        "  if align == '':\n",
                        "    return display(HTML(df.to_html().replace('\\\\n',\"<br>\")))\n",
                        "  else:\n",
                        "    print (\"pretty_print\")\n",
                        "    left_aligned_df = df.style.set_properties(**{'text-align': 'left'})\n",
                        "    left_aligned_df = left_aligned_df.set_table_styles(\n",
                        "        [dict(selector='th', props=[('text-align', 'left')])]\n",
                        "        )\n",
                        "    print( left_aligned_df.to_html().replace('\\\\n',\"<br>\"))\n",
                        "    return display( HTML(left_aligned_df.to_html().replace('\\\\n',\"<br>\")))\n",
                        "\n",
                        "def displayIPsStatusBarchart():\n",
                        "  df = pd.DataFrame(IPsMetricsStatusVct)\n",
                        "  df.groupby(['Metric','Value']).sum().unstack().plot(kind='bar')\n",
                        "    \n",
                        "def cvNaFlag(flagApplicable):\n",
                        "  if not flagApplicable:\n",
                        "    return 'N/A'\n",
                        "  else:\n",
                        "    return ''\n",
                        "\n",
                        "def cvExecutedFlag(statusObject):\n",
                        "  if not statusObject['Applicable']:\n",
                        "    return \"N/A\"\n",
                        "  elif statusObject['Executed']:\n",
                        "    return 'Executed'\n",
                        "  else:\n",
                        "    return 'Not Executed'\n",
                        "\n",
                        "def cvLpStatus(statusObject):\n",
                        "  if not statusObject['Applicable']:\n",
                        "    return \"N/A\"\n",
                        "  elif not statusObject['Executed']:\n",
                        "    return 'Not Executed'\n",
                        "  elif statusObject['PASS']==1 :\n",
                        "    return 'PASS'\n",
                        "  else:\n",
                        "    return 'Failed'\n",
                        "    \n",
                        "\n",
                        "def getAssessmentStatus():\n",
                        "  incomplete=False\n",
                        "  for i in range(len(MetricsStatusVct)):\n",
                        "    if MetricsStatusVct[i]['Applicable'] and not MetricsStatusVct[i]['Executed']:\n",
                        "      incomplete=True  \n",
                        "  if incomplete:\n",
                        "    return 'Incomplete'  \n",
                        "  if MetricsStatusVct[IndexLpMetadata]['PASS']==1 and MetricsStatusVct[IndexLpOrdinary]['PASS']==1 and MetricsStatusVct[IndexLpThematic]['PASS']==1:\n",
                        "    return 'PASS'\n",
                        "  else:\n",
                        "    return 'FAILED'\n",
                        "\n",
                        "#generate_production_and_validation_quality_indicators_report(\"http://qcmms.esa.int/quality-indicators/#lpInterpretationMetric\")\n",
                        "#@title Generate Overall Assessment\n",
                        "def generate_overall_assessment():\n",
                        "  table_title =['Task','Assessment', 'Status','Nb Pass','Nb Failed']\n",
                        "  table_index = ['','','','','','','','','','','']\n",
                        "  table_report = []\n",
                        "  lpMd = getLandProduct()\n",
                        "  nb_ip=countImageProductByMetric('','')\n",
                        "  if(lpMd != {}):\n",
                        "    \n",
                        "    table_report=[\n",
                        "      ['0.','Land Product Definitions','PASS','',''],\n",
                        "      ['1.','Production Feasibility',                cvExecutedFlag(MetricsStatusVct[IndexFeasibility]),\n",
                        "             MetricsStatusVct[IndexFeasibility]['PASS'],MetricsStatusVct[IndexFeasibility]['FAILED']],   \n",
                        "      ['2.','Delivery Control (images availability)',cvExecutedFlag(MetricsStatusVct[IndexDelivery]),\n",
                        "             MetricsStatusVct[IndexDelivery]['PASS'],MetricsStatusVct[IndexDelivery]['FAILED']],\n",
                        "      ['3A.','Ordinary Control (scene-level)', cvExecutedFlag(MetricsStatusVct[IndexOrdinary]),\n",
                        "             MetricsStatusVct[IndexOrdinary]['PASS'],MetricsStatusVct[IndexOrdinary]['FAILED']], \n",
                        "      ['3B.','Detailed Control (pixel-level)', cvExecutedFlag(MetricsStatusVct[IndexDetailed]),\n",
                        "             MetricsStatusVct[IndexDetailed]['PASS'],MetricsStatusVct[IndexDetailed]['FAILED']], \n",
                        "      ['4A.','Harmonization',                  cvExecutedFlag(MetricsStatusVct[IndexHarmonization]),\n",
                        "             MetricsStatusVct[IndexHarmonization]['PASS'],MetricsStatusVct[IndexHarmonization]['FAILED']],\n",
                        "      ['4B.','Fit-for-purpose',                cvLpStatus(MetricsStatusVct[IndexIpForLp]),         \n",
                        "             MetricsStatusVct[IndexIpForLp]['PASS'],MetricsStatusVct[IndexIpForLp]['FAILED']],  \n",
                        "      ['5.','Production Quality Indicators',   cvLpStatus(MetricsStatusVct[IndexLpInterpretation]),\n",
                        "             MetricsStatusVct[IndexLpInterpretation]['PASS'],MetricsStatusVct[IndexLpInterpretation]['FAILED']],\n",
                        "      ['6A.','Metadata Control Indicators',    cvLpStatus(MetricsStatusVct[IndexLpMetadata]),\n",
                        "             MetricsStatusVct[IndexLpMetadata]['PASS'],MetricsStatusVct[IndexLpMetadata]['FAILED']],\n",
                        "      ['6B.','Ordinary Control Indicators',    cvLpStatus(MetricsStatusVct[IndexLpOrdinary]),      \n",
                        "             MetricsStatusVct[IndexLpOrdinary]['PASS'],MetricsStatusVct[IndexLpOrdinary]['FAILED']],\n",
                        "      ['6C.','Thematic Validation Indicators', cvLpStatus(MetricsStatusVct[IndexLpThematic]),      \n",
                        "             MetricsStatusVct[IndexLpThematic]['PASS'],MetricsStatusVct[IndexLpThematic]['FAILED']]          \n",
                        "    ]\n",
                        "    \n",
                        "    pd_report = pd.DataFrame(table_report , index=table_index,columns = table_title)\n",
                        "    display(pd_report)\n",
                        "\n",
                        "     \n",
                        "#@title Interpretation Form (not used)\n",
                        "#\n",
                        "# Store and retrieve in a file (JSON object stored as a string in a file)\n",
                        "# the text entered by the user in the all textarea associated to the different tables/figures of the report\n",
                        "interpretationFile = 'interpretations.json'\n",
                        "interpretationList=['feasibility','cloudPercentages','delivery','ordinary','detailed','detailedStat','geometry']\n",
                        "#  object that with attributes above and text read and entered by the user\n",
                        "interpretationTexts={}\n",
                        "# object that contains for each textarea the associated widget object\n",
                        "interpretationWdgts={}\n",
                        "defaultText=''\n",
                        "wdgtPlaceHolder='Enter your interpretation for '\n",
                        "\n",
                        "def initInterpretationTexts():\n",
                        "# read interpretation comment from a file located in the same place than the notebook\n",
                        "  interpretations={}\n",
                        "  try:\n",
                        "    with open(interpretationFile) as json_file:\n",
                        "      interpretations = json.load(json_file)\n",
                        "#     check that different text areas had been save. Initialize new textareas (update report definition).\n",
                        "      for i in range(len(interpretationList)):\n",
                        "        try:\n",
                        "          interpretationName=interpretations[interpretationList[i]]\n",
                        "        except KeyError:\n",
                        "          interpretations[interpretationName]=defaultText \n",
                        "  except Exception as e:\n",
                        "    for i in range(len(interpretationList)):\n",
                        "      interpretationName=interpretationList[i]\n",
                        "      interpretations[interpretationName]=defaultText\n",
                        "  return interpretations\n",
                        "\n",
                        "# read from file\n",
                        "interpretationTexts=initInterpretationTexts()\n",
                        "\n",
                        "# create one text area to enter interpretation comments\n",
                        "def createTextArea(interpretationName):\n",
                        "  wdgtNote=widgets.HTML(\n",
                        "    value=\"<b><i>Interpretation note:</i></b>\"\n",
                        "    )\n",
                        "  wdgt=widgets.Textarea(\n",
                        "    value=interpretationTexts[interpretationName],\n",
                        "    placeholder=wdgtPlaceHolder + interpretationName,\n",
                        "    disabled=False,\n",
                        "    layout=widgets.Layout(width='800px', height='80px'))\n",
                        "  interpretationWdgts[interpretationName]=wdgt\n",
                        "  wdgtAll=widgets.VBox((wdgtNote,wdgt))\n",
                        "  display(wdgtAll)\n",
                        "\n",
                        "# display the button to save the entered interpretation texts in the file.\n",
                        "def createSaveButton():\n",
                        "  button = widgets.Button(description='Save your inputs',background_color='gray',layout=widgets.Layout(width='200px'))\n",
                        "  display(button)\n",
                        "  button.on_click(on_click)\n",
                        "# called back activated when the button is clicked\n",
                        "# save the interpretations in a file.\n",
                        "def on_click(b):\n",
                        "  for i in range(len(interpretationList)):\n",
                        "    interpretationTexts[interpretationList[i]]=interpretationWdgts[interpretationList[i]].value\n",
                        "  with open(interpretationFile,'w') as outfile:\n",
                        "    json.dump(interpretationTexts, outfile)\n",
                        "  display(interpretationTexts)  \n",
                        "#@title Default title text\n",
                        "#lpMd=getLandProduct()\n",
                        "#ipUrl=initImageProductsUrl()\n",
                        "#platforms=initPlatforms(lpMd)\n",
                        "#@title Generate Report Title\n",
                        "def generateReportTitle(lpMd):\n",
                        "  title=lpMd['properties']['title']\n",
                        "  productFocus=lpMd['properties']['additionalAttributes']['product_focus']\n",
                        "  display(widgets.HTML(\n",
                        "  value=  \n",
                        "  '<br><font size=\"18\"><center>Mapping Production</center></font>' +\n",
                        "  '<br><font size=\"20\"><center>QUALITY ASSESSMENT REPORT</center></font>' +\n",
                        "  '<br><font size=\"16\"><center>Demo: '+ title+'</center><font>'\n",
                        "  ))\n",
                        "\n",
                        "generateReportTitle(lpMd)"
                      ],
                      "cell_type": "code"
                    },
                    {
                      "metadata": {
                        "colab_type": "text",
                        "id": "Orw-S3cR8OQu"
                      },
                      "source": [
                        "\n",
                        "\n",
                        "\n",
                        "\n",
                        "\n",
                        "\n",
                        "\n",
                        "**Prepared by:**\n",
                        "\n",
                        "QCMMS Team\n",
                        "\n",
                        "\n",
                        "\n",
                        "\n",
                        "\n",
                        "# 1. Introduction\n",
                        "\n",
                        "\n",
                        "\n",
                        "This document is the QCMMS Quality Assessment Report based\n",
                        "on collected quality-related metadata by QC-Manager, stored in Catalog\n",
                        "and analysed by QA-Report manager. The report\n",
                        "\n",
                        "-   provides insights about the quality of the whole mapping process (based on simplified analytic information);\n",
                        "\n",
                        "-   informs the service user, and the service provider, about the potential quality issues at each stage during the manufacturing of the land product;\n",
                        "\n",
                        "-   guides the reader to trace the error / uncertainty source from the report and catalogued metadata towards the critical process;\n",
                        "\n",
                        "-   and provides final quality assement about the mapped product (delivery: Yes / No).\n",
                        "\n",
                        "\n",
                        "\n",
                        "\n",
                        "\n",
                        "\n"
                      ],
                      "cell_type": "markdown"
                    },
                    {
                      "metadata": {
                        "colab_type": "text",
                        "id": "6-jYCu92fHzJ"
                      },
                      "source": [
                        "# 2. Applicable and Reference Documents"
                      ],
                      "cell_type": "markdown"
                    },
                    {
                      "metadata": {
                        "colab_type": "text",
                        "id": "ANi_TQ06fZ_K"
                      },
                      "source": [
                        "# 3. Terms, Definitions And Abbreviated Terms"
                      ],
                      "cell_type": "markdown"
                    },
                    {
                      "metadata": {
                        "colab_type": "text",
                        "id": "TKnPZjK1foeD"
                      },
                      "source": [
                        "## 3.1 Definitions\n"
                      ],
                      "cell_type": "markdown"
                    },
                    {
                      "outputs": [],
                      "metadata": {
                        "colab_type": "code",
                        "colab": {},
                        "id": "jTr1DOzltiof"
                      },
                      "execution_count": null,
                      "source": [
                        "generateDefinitions()\n"
                      ],
                      "cell_type": "code"
                    },
                    {
                      "metadata": {
                        "colab_type": "text",
                        "id": "XIks-zjtf6Nm"
                      },
                      "source": [
                        "## 3.2 Abbreviated Terms"
                      ],
                      "cell_type": "markdown"
                    },
                    {
                      "outputs": [],
                      "metadata": {
                        "colab_type": "code",
                        "colab": {},
                        "id": "GL6Q4BTOttpG"
                      },
                      "execution_count": null,
                      "source": [
                        "generateAbbreviations()"
                      ],
                      "cell_type": "code"
                    },
                    {
                      "metadata": {
                        "colab_type": "text",
                        "id": "Z_g1BuzTvcfo"
                      },
                      "source": [
                        "# 4. Processing Report"
                      ],
                      "cell_type": "markdown"
                    },
                    {
                      "metadata": {
                        "colab_type": "text",
                        "id": "2pzQ4UtWeYF_"
                      },
                      "source": [
                        "## 4.1 Land Product Definitions\n",
                        "\n",
                        "This section provides information about the land product definition and technical specifications."
                      ],
                      "cell_type": "markdown"
                    },
                    {
                      "outputs": [],
                      "metadata": {
                        "colab_type": "code",
                        "colab": {},
                        "cellView": "both",
                        "id": "8YNdKRL-4ruF"
                      },
                      "execution_count": null,
                      "source": [
                        "#@title \n",
                        "res=generate_lp_definition_report(tableNbr)\n",
                        "tableNbr=res['tableNbr']\n",
                        "geometric_resolution=res['geometric_resolution']"
                      ],
                      "cell_type": "code"
                    },
                    {
                      "metadata": {
                        "colab_type": "text",
                        "id": "2vJ3IsSSqr3j"
                      },
                      "source": [
                        "In the previous table, the \"Thematic accuracy\" is the percentage of user's / producer's accuracy (sealing levels > 20-30%). "
                      ],
                      "cell_type": "markdown"
                    },
                    {
                      "metadata": {
                        "colab_type": "text",
                        "id": "WRZssje-62pn"
                      },
                      "source": [
                        "## 4.2 Production Feasibility Control"
                      ],
                      "cell_type": "markdown"
                    },
                    {
                      "metadata": {
                        "colab_type": "text",
                        "id": "n8RGrtH47c05"
                      },
                      "source": [
                        "This section computes the number of input products that pass or not pass a quality check among the set of products selected to build the land product. These quality checks are extracted from the product metadata retrieved in the archive.  \n"
                      ],
                      "cell_type": "markdown"
                    },
                    {
                      "outputs": [],
                      "metadata": {
                        "colab_type": "code",
                        "colab": {},
                        "cellView": "code",
                        "id": "rDOtpO_p7CgE"
                      },
                      "execution_count": null,
                      "source": [
                        "#@title\n",
                        "if alreadyExecuted(IndexFeasibility):\n",
                        "  for i in range(len(platforms)): \n",
                        "     tableNbr=generateTableLabel(tableNbr,'General IP quality metadata overview as retrieved from archive for ' + platforms[i])\n",
                        "     generate_feasibility_control_report(platforms[i])\n",
                        "#createTextArea('feasibility')\n"
                      ],
                      "cell_type": "code"
                    },
                    {
                      "metadata": {
                        "colab_type": "text",
                        "id": "0Bp7ICoRIEmQ"
                      },
                      "source": [
                        "The following graph shows on y-axis the number of images with a cloud cover percentage provided on x-axis."
                      ],
                      "cell_type": "markdown"
                    },
                    {
                      "outputs": [],
                      "metadata": {
                        "colab_type": "code",
                        "colab": {},
                        "id": "jC72z9oeHz36"
                      },
                      "execution_count": null,
                      "source": [
                        "#@title \n",
                        "if alreadyExecuted(IndexFeasibility):\n",
                        "  for i in range(len(platforms)): \n",
                        "     fgNbr=generateHist(fgNbr,platforms[i])"
                      ],
                      "cell_type": "code"
                    },
                    {
                      "metadata": {
                        "colab_type": "text",
                        "id": "bzidfrzt7zGU"
                      },
                      "source": [
                        "## 4.3 Delivery Control"
                      ],
                      "cell_type": "markdown"
                    },
                    {
                      "metadata": {
                        "colab_type": "text",
                        "id": "F22p1jBD9EVG"
                      },
                      "source": [
                        "The following table provides information about the download status of the products used to build the Land Product.\n",
                        "\n",
                        "  \n",
                        "\n"
                      ],
                      "cell_type": "markdown"
                    },
                    {
                      "outputs": [],
                      "metadata": {
                        "colab_type": "code",
                        "colab": {},
                        "cellView": "both",
                        "id": "ESC2lrEr61Ce"
                      },
                      "execution_count": null,
                      "source": [
                        "#@title \n",
                        "if alreadyExecuted(IndexDelivery):\n",
                        "  for i in range(len(platforms)): \n",
                        "    tableNbr=generateTableLabel(tableNbr,'Tabulated overview of the delivery control for ' + platforms[i])\n",
                        "    generate_delivery_control_report(platforms[i])\n",
                        "#createTextArea('delivery')"
                      ],
                      "cell_type": "code"
                    },
                    {
                      "metadata": {
                        "colab_type": "text",
                        "id": "evBoSpY-890-"
                      },
                      "source": [
                        "## 4.4 Ordinary Control"
                      ],
                      "cell_type": "markdown"
                    },
                    {
                      "metadata": {
                        "colab_type": "text",
                        "id": "ehsE4wOq9DdC"
                      },
                      "source": [
                        "The ordinary control provides information about quality checks done at the level of the input products raster related metadata for the different levels of processings. "
                      ],
                      "cell_type": "markdown"
                    },
                    {
                      "outputs": [],
                      "metadata": {
                        "colab_type": "code",
                        "colab": {},
                        "cellView": "code",
                        "id": "pnwhFJpS7Cko"
                      },
                      "execution_count": null,
                      "source": [
                        "#@title\n",
                        "if alreadyExecuted(IndexOrdinary):\n",
                        "  for i in range(len(platforms)):\n",
                        "    tableNbr=generateTableLabel(tableNbr,'Tabulated overview of the L1 & L2 products ordinary control for '+ platforms[i])\n",
                        "    generate_ordinary_control_report(platforms[i])\n",
                        "#createTextArea('ordinary')"
                      ],
                      "cell_type": "code"
                    },
                    {
                      "metadata": {
                        "colab_type": "text",
                        "id": "DKFTRFTNKuev"
                      },
                      "source": [
                        "Information about the table content:  \n",
                        "*   Rasters complete:  number of products with complete rasters\n",
                        "*   Rasters read: number of products that pass the test to read the respective image band \n",
                        "*   Calibration metadata: number of products that pass the calibration metadata availability checks\n",
                        "*   Metadata read: number of products that pass the metadata check\n",
                        "*   Total: number of products which pass or fail this \"ordinary check\" and include \"ordinary check\" quality metadata for the corresponding processing level."
                      ],
                      "cell_type": "markdown"
                    },
                    {
                      "outputs": [],
                      "metadata": {
                        "colab_type": "code",
                        "colab": {},
                        "id": "PkG9nVTxK-v-"
                      },
                      "execution_count": null,
                      "source": [
                        ""
                      ],
                      "cell_type": "code"
                    },
                    {
                      "metadata": {
                        "colab_type": "text",
                        "id": "O9pt-5Dm-VYK"
                      },
                      "source": [
                        "## 4.5 Detailed Control"
                      ],
                      "cell_type": "markdown"
                    },
                    {
                      "metadata": {
                        "colab_type": "text",
                        "id": "cu51gBCVPvSA"
                      },
                      "source": [
                        "This control is focused on detailed pixel-level quality metadata. For each input image, it generates a mask for different topics (cloud coverage, valid pixels, geometry). <br>The following table provides  the number of input products for which a mask has been generated in both cases: case where the detailed control status is \"PASS\" or \"FAILED\". <br> The \"Valid pixel metadata\" provides summary information about the usability of individual pixels within each scene that passed the previous quality assessment procedure.<br>\n",
                        "The \"Total\" column indicates the number of input products that pass or not this step."
                      ],
                      "cell_type": "markdown"
                    },
                    {
                      "outputs": [],
                      "metadata": {
                        "colab_type": "code",
                        "colab": {},
                        "id": "0Upp_i0o4XG7"
                      },
                      "execution_count": null,
                      "source": [
                        ""
                      ],
                      "cell_type": "code"
                    },
                    {
                      "outputs": [],
                      "metadata": {
                        "colab_type": "code",
                        "colab": {},
                        "cellView": "code",
                        "id": "moEGW2inEZ11"
                      },
                      "execution_count": null,
                      "source": [
                        "#@title \n",
                        "if alreadyExecuted(IndexDetailed):\n",
                        "  for i in range(len(platforms)): \n",
                        "    tableNbr=generateTableLabel(tableNbr,'Availability of the detailed pixel level quality metadata for '+ platforms[i])\n",
                        "    generate_detailed_control_report(platforms[i])"
                      ],
                      "cell_type": "code"
                    },
                    {
                      "metadata": {
                        "colab_type": "text",
                        "id": "T-wdZqKySvZg"
                      },
                      "source": [
                        "The following table provides statistics (mean) on cloud coverage, geometry quality parameters computed on the set of input products. It also provides the number of these products for which the maximum difference on X and Y is greater than the land product required geometry  accuracy."
                      ],
                      "cell_type": "markdown"
                    },
                    {
                      "outputs": [],
                      "metadata": {
                        "colab_type": "code",
                        "colab": {},
                        "id": "QtvKDiVsRYWn"
                      },
                      "execution_count": null,
                      "source": [
                        "#@title \n",
                        "if alreadyExecuted(IndexDetailed):\n",
                        "  for i in range(len(platforms)): \n",
                        "    tableNbr=generateTableLabel(tableNbr,'Summary statistics of the pixel level quality metadata for '+ platforms[i])\n",
                        "    generate_detailed_control_stat_report(platforms[i])"
                      ],
                      "cell_type": "code"
                    },
                    {
                      "metadata": {
                        "colab_type": "text",
                        "id": "OWrAV-XqXzuU"
                      },
                      "source": [
                        "The following picture is a plot of the DiffX, DiffY values from the input images. The displayed circle radius has been computed to include 90% of these points."
                      ],
                      "cell_type": "markdown"
                    },
                    {
                      "outputs": [],
                      "metadata": {
                        "colab_type": "code",
                        "colab": {},
                        "id": "thdp-S5iRnBJ"
                      },
                      "execution_count": null,
                      "source": [
                        "#@title \n",
                        "if alreadyExecuted(IndexDetailed):\n",
                        "  for i in range(len(platforms)):\n",
                        "    #tableNbr=generateTableLabel(tableNbr,'Tabulated overview of the L1 & L2 products ordinary control for '+ platforms[i])\n",
                        "    #print(platforms[i])\n",
                        "    fgNbr=generate_Plot_CE(fgNbr,platforms[i])"
                      ],
                      "cell_type": "code"
                    },
                    {
                      "metadata": {
                        "colab_type": "text",
                        "id": "f4DDRd-8aTJ2"
                      },
                      "source": [
                        "## 4.6 Harmonization Control"
                      ],
                      "cell_type": "markdown"
                    },
                    {
                      "outputs": [],
                      "metadata": {
                        "colab_type": "code",
                        "colab": {},
                        "cellView": "code",
                        "id": "LhmXebjJahk6"
                      },
                      "execution_count": null,
                      "source": [
                        "#@title \n",
                        "if alreadyExecuted(IndexHarmonization):\n",
                        "  \n",
                        "  for i in range(len(platforms)):\n",
                        "    res=displayRadiometryConsistencyBarchart(fgNbr,platforms[i])\n",
                        "    fgNbr=res['fgNbr']\n",
                        "    references=res['references']"
                      ],
                      "cell_type": "code"
                    },
                    {
                      "outputs": [],
                      "metadata": {
                        "colab_type": "code",
                        "colab": {},
                        "cellView": "form",
                        "id": "cC5dcVKyultb"
                      },
                      "execution_count": null,
                      "source": [
                        "#@title \n",
                        "print(\"References:\")\n",
                        "for i in range(len(references)): \n",
                        "  print(references[i]['category'] +\": \" + references[i]['title'] ) "
                      ],
                      "cell_type": "code"
                    },
                    {
                      "metadata": {
                        "colab_type": "text",
                        "id": "cswIwG7o8imN"
                      },
                      "source": [
                        "## 4.7 Fit-for-Purpose Control\n",
                        "\n",
                        "The following images present aggregations from valid pixels metadata over N image products computed by year (red= gaps). "
                      ],
                      "cell_type": "markdown"
                    },
                    {
                      "outputs": [],
                      "metadata": {
                        "colab_type": "code",
                        "colab": {},
                        "cellView": "both",
                        "id": "2RAlku2JuDL5"
                      },
                      "execution_count": null,
                      "source": [
                        "#@title \n",
                        "if alreadyExecuted(IndexIpForLp):\n",
                        "  fgNbr=getFitForPurpose(fgNbr)"
                      ],
                      "cell_type": "code"
                    },
                    {
                      "metadata": {
                        "colab_type": "text",
                        "id": "mSbpzWtX8qTq"
                      },
                      "source": [
                        "## 4.8 Production Quality Indicators\n",
                        "\n",
                        "Subject: Evaluate model indicators for traceability.\n"
                      ],
                      "cell_type": "markdown"
                    },
                    {
                      "outputs": [],
                      "metadata": {
                        "colab_type": "code",
                        "colab": {},
                        "cellView": "code",
                        "id": "JTpsNXp89oSW"
                      },
                      "execution_count": null,
                      "source": [
                        "#@title \n",
                        "if alreadyExecuted(IndexLpInterpretation):\n",
                        "  tableNbr=generateTableLabel(tableNbr,'Interpretation model training indicators for Urban mask')\n",
                        "  generate_production_and_validation_quality_indicators_report(\"http://qcmms.esa.int/quality-indicators/#lpInterpretationMetric\")\n"
                      ],
                      "cell_type": "code"
                    },
                    {
                      "metadata": {
                        "colab_type": "text",
                        "id": "wVtt1Kh53Yld"
                      },
                      "source": [
                        "## 4.9 Land Product Validation Quality Indicators\n",
                        "\n",
                        "This section provides accuracy indicators of the independent validation for\n",
                        "the resulting land product."
                      ],
                      "cell_type": "markdown"
                    },
                    {
                      "outputs": [],
                      "metadata": {
                        "colab_type": "code",
                        "colab": {},
                        "cellView": "code",
                        "id": "p8lwpsmO4UM7"
                      },
                      "execution_count": null,
                      "source": [
                        "\n",
                        "\n",
                        "\n",
                        "#@title \n",
                        "if alreadyExecuted(IndexLpThematic):\n",
                        "  tableNbr=generateTableLabel(tableNbr,'Land product independent validation indicators')\n",
                        "  generate_production_and_validation_quality_indicators_report(\"http://qcmms.esa.int/quality-indicators/#lpThematicValidationMetric\")"
                      ],
                      "cell_type": "code"
                    },
                    {
                      "metadata": {
                        "colab_type": "text",
                        "id": "cg4_lUUngUv1"
                      },
                      "source": [
                        "## 4.10 Land Product Metadata Control \n",
                        "\n"
                      ],
                      "cell_type": "markdown"
                    },
                    {
                      "outputs": [],
                      "metadata": {
                        "colab_type": "code",
                        "colab": {},
                        "id": "ONlzzHW8hhL3"
                      },
                      "execution_count": null,
                      "source": [
                        "if alreadyExecuted(IndexLpMetadata):\n",
                        "  generate_metadata_control_report()"
                      ],
                      "cell_type": "code"
                    },
                    {
                      "metadata": {
                        "colab_type": "text",
                        "id": "IKsywXGCp3qH"
                      },
                      "source": [
                        "## 4.11 Land Product Ordinary Control "
                      ],
                      "cell_type": "markdown"
                    },
                    {
                      "outputs": [],
                      "metadata": {
                        "colab_type": "code",
                        "colab": {},
                        "id": "OGl6mQG0rcCG"
                      },
                      "execution_count": null,
                      "source": [
                        "if alreadyExecuted(IndexLpOrdinary):\n",
                        "  tableNbr=generateTableLabel(tableNbr,'Land product ordinary control parameters')\n",
                        "  generate_product_ordinary_control_report()"
                      ],
                      "cell_type": "code"
                    },
                    {
                      "metadata": {
                        "colab_type": "text",
                        "id": "C6HeWXYV_bVo"
                      },
                      "source": [
                        "## 4.12 Overall Assessment"
                      ],
                      "cell_type": "markdown"
                    },
                    {
                      "metadata": {
                        "colab_type": "text",
                        "id": "rrIX9MZy_uR-"
                      },
                      "source": [
                        "\n",
                        "\n",
                        "This section provides an overall assessment of the quality analysis. The following bar chart shows the number of image products that could pass or not pass the quality check associated to a processing step."
                      ],
                      "cell_type": "markdown"
                    },
                    {
                      "outputs": [],
                      "metadata": {
                        "colab_type": "code",
                        "colab": {},
                        "cellView": "code",
                        "id": "UUrCD1u6-osj"
                      },
                      "execution_count": null,
                      "source": [
                        "#@title\n",
                        "tableNbr=generateTableLabel(tableNbr,'Metric values for Image Products')\n",
                        "displayIPsStatusBarchart()\n"
                      ],
                      "cell_type": "code"
                    },
                    {
                      "outputs": [],
                      "metadata": {
                        "colab_type": "code",
                        "colab": {},
                        "id": "UCNgvyvNIVrd"
                      },
                      "execution_count": null,
                      "source": [
                        "tableNbr=generateTableLabel(tableNbr,'Overall Assessment')\n",
                        "generate_overall_assessment()"
                      ],
                      "cell_type": "code"
                    }
                  ],
                  "nbformat": 4
                }
              },
              "application/vnd.iso.19157-2": {
                "schema": {
                  "$ref": "#/components/schemas/Feature"
                },
                "example": "<mdq:DQ_DataQuality xmlns:mdq=\"http://standards.iso.org/iso/19157/-2/mdq/1.0\"\r\n                    xmlns:gco=\"http://standards.iso.org/iso/19115/-3/gco/1.0\"\r\n                    xmlns:mcc=\"http://standards.iso.org/iso/19115/-3/mcc/1.0\"\r\n                    xmlns:cit=\"http://standards.iso.org/iso/19115/-3/cit/1.0\"\r\n                    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n                    xsi:schemaLocation=\"http://standards.iso.org/iso/19157/-2/mdq/1.0 mdq.xsd\">\r\n   <mdq:scope>\r\n      <mcc:MD_Scope>\r\n         <mcc:level>\r\n            <mcc:MD_ScopeCode codeList=\"http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ScopeCode\"\r\n                              codeListValue=\"dataset\">dataset</mcc:MD_ScopeCode>\r\n         </mcc:level>\r\n         <mcc:levelDescription>\r\n            <mcc:MD_ScopeDescription>\r\n               <mcc:other>\r\n                  <gco:CharacterString>This is a quality report for the (land product) dataset generated by the qcmms processing pipeline</gco:CharacterString>\r\n               </mcc:other>\r\n            </mcc:MD_ScopeDescription>\r\n         </mcc:levelDescription>\r\n      </mcc:MD_Scope>\r\n   </mdq:scope>\r\n   <mdq:standaloneQualityReport>\r\n      <mdq:DQ_StandaloneQualityReportInformation>\r\n         <mdq:reportReference>\r\n            <cit:CI_Citation>\r\n               <cit:title>\r\n                  <gco:CharacterString>Online quality report by QCMMS in Jupyter notebook format</gco:CharacterString>\r\n               </cit:title>\r\n               <cit:onlineResource>\r\n                  <cit:CI_onlineResource>\r\n                     <cit:linkage>\r\n                        <gco:CharacterString>SERVER_URL/series/EOP:ESA:LP:UC1/datasets/IMD_2018_010m?httpAccept=application/x-ipynb%2Bjson</gco:CharacterString>\r\n                     </cit:linkage>\r\n                     <cit:protocol>\r\n                        <gco:CharacterString>http</gco:CharacterString>\r\n                     </cit:protocol>\r\n                     <cit:function>\r\n                        <cit:CI_OnlineFunctionCode>information</cit:CI_OnlineFunctionCode>\r\n                     </cit:function>\r\n                  </cit:CI_onlineResource>\r\n               </cit:onlineResource>\r\n            </cit:CI_Citation>\r\n         </mdq:reportReference>\r\n         <mdq:abstract>\r\n            <gco:CharacterString>The stand-alone quality report is a dynamic report which can be used to monitor quality during the processing.  It accesses quality information from the online QCMMS metadata catalogue.</gco:CharacterString>\r\n         </mdq:abstract>\r\n      </mdq:DQ_StandaloneQualityReportInformation>\r\n   </mdq:standaloneQualityReport>\r\n   <mdq:report>\r\n      <mdq:DQ_UsabilityElement>\r\n         <mdq:measure>\r\n            <mdq:DQ_MeasureReference>\r\n               <mdq:measureIdentification>\r\n                  <mcc:MD_Identifier>\r\n                     <mcc:code>\r\n                        <gco:CharacterString>http://qcmms.esa.int/quality-indicators/#ipForLpInformationMetric</gco:CharacterString>\r\n                     </mcc:code>\r\n                  </mcc:MD_Identifier>\r\n               </mdq:measureIdentification>\r\n               <mdq:nameOfMeasure>\r\n                  <gco:CharacterString>image products information used for the land product control</gco:CharacterString>\r\n               </mdq:nameOfMeasure>\r\n            </mdq:DQ_MeasureReference>\r\n         </mdq:measure>\r\n         <mdq:result>\r\n            <mdq:DQ_ConformanceResult>\r\n               <mdq:dateTime>\r\n                  <gco:DateTime>2020-06-17T16:27:09.98Z</gco:DateTime>\r\n               </mdq:dateTime>\r\n               <mdq:specification/>\r\n               <mdq:explanation>\r\n                  <gco:CharacterString>result of the image products information used for the land product control</gco:CharacterString>\r\n               </mdq:explanation>\r\n               <mdq:pass>\r\n                  <gco:Boolean>true</gco:Boolean>\r\n               </mdq:pass>\r\n            </mdq:DQ_ConformanceResult>\r\n         </mdq:result>\r\n      </mdq:DQ_UsabilityElement>\r\n   </mdq:report>\r\n   <mdq:report>\r\n      <mdq:DQ_ThematicClassificationCorrectness>\r\n         <mdq:measure>\r\n            <mdq:DQ_MeasureReference>\r\n               <mdq:measureIdentification>\r\n                  <mcc:MD_Identifier>\r\n                     <mcc:code>\r\n                        <gco:CharacterString>http://qcmms.esa.int/quality-indicators/#lpInterpretationMetric</gco:CharacterString>\r\n                     </mcc:code>\r\n                  </mcc:MD_Identifier>\r\n               </mdq:measureIdentification>\r\n               <mdq:nameOfMeasure>\r\n                  <gco:CharacterString>land product interpretation control</gco:CharacterString>\r\n               </mdq:nameOfMeasure>\r\n            </mdq:DQ_MeasureReference>\r\n         </mdq:measure>\r\n         <mdq:result>\r\n            <mdq:DQ_ConformanceResult>\r\n               <mdq:dateTime>\r\n                  <gco:DateTime>2020-06-17T16:27:20.58Z</gco:DateTime>\r\n               </mdq:dateTime>\r\n               <mdq:specification/>\r\n               <mdq:explanation>\r\n                  <gco:CharacterString>result of the land product interpretation control</gco:CharacterString>\r\n               </mdq:explanation>\r\n               <mdq:pass>\r\n                  <gco:Boolean>true</gco:Boolean>\r\n               </mdq:pass>\r\n            </mdq:DQ_ConformanceResult>\r\n         </mdq:result>\r\n      </mdq:DQ_ThematicClassificationCorrectness>\r\n   </mdq:report>\r\n   <mdq:report>\r\n      <mdq:DQ_ConceptualConsistency>\r\n         <mdq:measure>\r\n            <mdq:DQ_MeasureReference>\r\n               <mdq:measureIdentification>\r\n                  <mcc:MD_Identifier>\r\n                     <mcc:code>\r\n                        <gco:CharacterString>http://qcmms.esa.int/quality-indicators/#lpMetadataControlMetric</gco:CharacterString>\r\n                     </mcc:code>\r\n                  </mcc:MD_Identifier>\r\n               </mdq:measureIdentification>\r\n               <mdq:nameOfMeasure>\r\n                  <gco:CharacterString>land product metadata control</gco:CharacterString>\r\n               </mdq:nameOfMeasure>\r\n            </mdq:DQ_MeasureReference>\r\n         </mdq:measure>\r\n         <mdq:result>\r\n            <mdq:DQ_ConformanceResult>\r\n               <mdq:dateTime>\r\n                  <gco:DateTime>2020-06-17T16:27:20.59Z</gco:DateTime>\r\n               </mdq:dateTime>\r\n               <mdq:specification/>\r\n               <mdq:explanation>\r\n                  <gco:CharacterString>result of the land product metadata control</gco:CharacterString>\r\n               </mdq:explanation>\r\n               <mdq:pass>\r\n                  <gco:Boolean>true</gco:Boolean>\r\n               </mdq:pass>\r\n            </mdq:DQ_ConformanceResult>\r\n         </mdq:result>\r\n      </mdq:DQ_ConceptualConsistency>\r\n   </mdq:report>\r\n   <mdq:report>\r\n      <mdq:DQ_ConceptualConsistency>\r\n         <mdq:measure>\r\n            <mdq:DQ_MeasureReference>\r\n               <mdq:measureIdentification>\r\n                  <mcc:MD_Identifier>\r\n                     <mcc:code>\r\n                        <gco:CharacterString>http://qcmms.esa.int/quality-indicators/#lpOrdinaryControlMetric</gco:CharacterString>\r\n                     </mcc:code>\r\n                  </mcc:MD_Identifier>\r\n               </mdq:measureIdentification>\r\n               <mdq:nameOfMeasure>\r\n                  <gco:CharacterString>land product ordinary control</gco:CharacterString>\r\n               </mdq:nameOfMeasure>\r\n            </mdq:DQ_MeasureReference>\r\n         </mdq:measure>\r\n         <mdq:result>\r\n            <mdq:DQ_ConformanceResult>\r\n               <mdq:dateTime>\r\n                  <gco:DateTime>2020-06-17T16:27:20.59Z</gco:DateTime>\r\n               </mdq:dateTime>\r\n               <mdq:specification/>\r\n               <mdq:explanation>\r\n                  <gco:CharacterString>Result of the land product ordinary control</gco:CharacterString>\r\n               </mdq:explanation>\r\n               <mdq:pass>\r\n                  <gco:Boolean>true</gco:Boolean>\r\n               </mdq:pass>\r\n            </mdq:DQ_ConformanceResult>\r\n         </mdq:result>\r\n      </mdq:DQ_ConceptualConsistency>\r\n   </mdq:report>\r\n   <mdq:report>\r\n      <mdq:DQ_ThematicClassificationCorrectness>\r\n         <mdq:measure>\r\n            <mdq:DQ_MeasureReference>\r\n               <mdq:measureIdentification>\r\n                  <mcc:MD_Identifier>\r\n                     <mcc:code>\r\n                        <gco:CharacterString>http://qcmms.esa.int/quality-indicators/#lpThematicValidationMetric</gco:CharacterString>\r\n                     </mcc:code>\r\n                  </mcc:MD_Identifier>\r\n               </mdq:measureIdentification>\r\n               <mdq:nameOfMeasure>\r\n                  <gco:CharacterString>land product thematic validation</gco:CharacterString>\r\n               </mdq:nameOfMeasure>\r\n            </mdq:DQ_MeasureReference>\r\n         </mdq:measure>\r\n         <mdq:result>\r\n            <mdq:DQ_ConformanceResult>\r\n               <mdq:dateTime>\r\n                  <gco:DateTime>2020-06-17T16:27:20.59Z</gco:DateTime>\r\n               </mdq:dateTime>\r\n               <mdq:specification/>\r\n               <mdq:explanation>\r\n                  <gco:CharacterString>Result of the land product thematic validation</gco:CharacterString>\r\n               </mdq:explanation>\r\n               <mdq:pass>\r\n                  <gco:Boolean>true</gco:Boolean>\r\n               </mdq:pass>\r\n            </mdq:DQ_ConformanceResult>\r\n         </mdq:result>\r\n      </mdq:DQ_ThematicClassificationCorrectness>\r\n   </mdq:report>\r\n</mdq:DQ_DataQuality>"
              }
            }
          },
          "400": {
            "description": "Bad request (invalid parameter)"
          },
          "404": {
            "description": "Dataset not found"
          },
		  "415": {
			"description": "Unsupported Media Type"
		  },
          "500": {
            "description": "Unexpected error"
          }
        }
      },
      "put": {
        "tags": [
          "Dataset"
        ],
        "description": "Insert a new dataset to the catalogue.",
        "operationId": "Update",
        "parameters": [
          {
            "name": "seriesId",
            "in": "path",
            "x-value": "{eo:parentIdentifier}",
            "required": true,
            "description": "Series identifier.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "datasetId",
            "in": "path",
            "x-value": "{geo:uid}",
            "required": true,
            "description": "Dataset identifier.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "Insert a new dataset to the catalogue.",
          "required": true,
          "content": {
            "application/geo+json": {
              "schema": {
                "$ref": "#/components/schemas/Feature"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Dataset has been successfully updated."
          },
          "400": {
            "description": "Bad request."
          },
          "415": {
            "description": "Unsupported Media Type."
          },
          "500": {
            "description": "Unexpected error"
          }
        }
      },
      "delete": {
        "description": "Delete a dataset from the catalogue.",
        "operationId": "Delete",
        "tags": [
          "Dataset"
        ],
        "parameters": [
          {
            "name": "seriesId",
            "in": "path",
            "x-value": "{eo:parentIdentifier}",
            "required": true,
            "description": "Series identifier.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "datasetId",
            "in": "path",
            "x-value": "{geo:uid}",
            "required": true,
            "description": "Dataset identifier.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Dataset has been deleted."
          },
          "500": {
            "description": "Unexpected error"
          }
        }
      }
    },
    "/series/{seriesId}/datasets/{datasetId}/links": {
      "post": {
        "description": "Create via element",
        "operationId": "CreateVia",
        "tags": [
          "Links"
        ],
        "parameters": [
          {
            "name": "seriesId",
            "in": "path",
            "x-value": "{eo:parentIdentifier}",
            "required": true,
            "description": "Series identifier.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "datasetId",
            "in": "path",
            "x-value": "{geo:uid}",
            "required": true,
            "description": "Dataset identifier.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "Create via links of a dataset.",
          "required": true,
          "content": {
            "application/geo+json": {
              "schema": {
                "$ref": "#/components/schemas/Links"
              },
              "example": [
                {
                  "href": "SERVER_URL/series/EOP:ESA:GR1:UC1/datasets",
                  "type": "application/geo+json",
                  "title": "Input data"
                }
              ]
            }
          }
        },
        "responses": {
          "201": {
            "description": "Via element has been created."
          },          
		  "404": {
            "description": "The product {datasetId} of series {seriesId} not found."
          },
		  "409": {
            "description": "Failed to update, via attribute is already existed. Use PUT method to update."
          },
          "500": {
            "description": "Unexpected error"
          }
        }
      }
    },
	"/series/{seriesId}/datasets/{datasetId}/links/via": {
      "post": {
        "description": "Add child links to via",
        "operationId": "AddViaLinks",
        "tags": [
          "Links"
        ],
        "parameters": [
          {
            "name": "seriesId",
            "in": "path",
            "x-value": "{eo:parentIdentifier}",
            "required": true,
            "description": "Series identifier.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "datasetId",
            "in": "path",
            "x-value": "{geo:uid}",
            "required": true,
            "description": "Dataset identifier.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "Add links to via element of a dataset.",
          "required": true,
          "content": {
            "application/geo+json": {
              "schema": {
                "$ref": "#/components/schemas/Links"
              },
              "example": [
                {
                  "href": "SERVER_URL/series/EOP:ESA:GR1:UC1/datasets",
                  "type": "application/geo+json",
                  "title": "Input data"
                }
              ]
            }
          }
        },
        "responses": {
          "201": {
            "description": "Child links have been added to via."
          },
          "400": {
            "description": "Failed to update, via attribute is not existed."
          },
		  "404": {
            "description": "The product {datasetId} of series {seriesId} not found."
          },
		  "409": {
            "description": "File {via_url} has already been associated to the product."
          },
          "500": {
            "description": "Unexpected error"
          }
        }
      },
	  "put": {
        "description": "Add child links to via",
        "operationId": "UpdateViaLinks",
        "tags": [
          "Links"
        ],
        "parameters": [
          {
            "name": "seriesId",
            "in": "path",
            "x-value": "{eo:parentIdentifier}",
            "required": true,
            "description": "Series identifier.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "datasetId",
            "in": "path",
            "x-value": "{geo:uid}",
            "required": true,
            "description": "Dataset identifier.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "Add links to via element of a dataset.",
          "required": true,
          "content": {
            "application/geo+json": {
              "schema": {
                "$ref": "#/components/schemas/Links"
              },
              "example": [
                {
                  "href": "SERVER_URL/series/EOP:ESA:GR1:UC1/datasets",
                  "type": "application/geo+json",
                  "title": "Input data"
                }
              ]
            }
          }
        },
        "responses": {
          "201": {
            "description": "Via links have been updated."
          },
          "400": {
            "description": "Failed to update, via attribute is not existed."
          },
		  "404": {
            "description": "The product {datasetId} of series {seriesId} not found."
          },
          "500": {
            "description": "Unexpected error"
          }
        }
      }
    },
    "/series/{seriesId}/datasets/{datasetId}/productInformation": {
      "post": {
        "description": "Create ProductInformation.",
        "operationId": "CreateProductInformation",
        "tags": [
          "ProductInformation"
        ],
        "parameters": [
          {
            "name": "seriesId",
            "in": "path",
            "x-value": "{eo:parentIdentifier}",
            "required": true,
            "description": "Series identifier.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "datasetId",
            "in": "path",
            "x-value": "{geo:uid}",
            "required": true,
            "description": "Dataset identifier.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "create quality indicators of a dataset.",
          "required": true,
          "content": {
            "application/geo+json": {
              "schema": {
                "$ref": "#/components/schemas/ProductInformation"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Quality indicators have been created."
          },
          "400": {
            "description": "Bad request. Indicator is already exsisted."
          },
          "500": {
            "description": "Unexpected error"
          }
        }
      }
    },
    "/series/{seriesId}/datasets/{datasetId}/productInformation/qualityInformation/qualityIndicators": {
      "put": {
        "description": "Update quality indicators.",
        "operationId": "UpdateQualityIndicators",
        "tags": [
          "QualityIndicators"
        ],
        "parameters": [
          {
            "name": "seriesId",
            "in": "path",
            "x-value": "{eo:parentIdentifier}",
            "required": true,
            "description": "Series identifier.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "datasetId",
            "in": "path",
            "x-value": "{geo:uid}",
            "required": true,
            "description": "Dataset identifier.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "update quality indicators of a dataset.",
          "required": true,
          "content": {
            "application/geo+json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/QualityIndicator"
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Quality indicators have been updated."
          },
          "400": {
            "description": "Bad request. Indicator not yet exsisted."
          },
          "500": {
            "description": "Unexpected error"
          }
        }
      },
      "post": {
        "description": "Create metrics.",
        "operationId": "CreateMetrics",
        "tags": [
          "QualityIndicators"
        ],
        "parameters": [
          {
            "name": "seriesId",
            "in": "path",
            "x-value": "{eo:parentIdentifier}",
            "required": true,
            "description": "Series identifier.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "datasetId",
            "in": "path",
            "x-value": "{geo:uid}",
            "required": true,
            "description": "Dataset identifier.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "create quality metrics of a dataset.",
          "required": true,
          "content": {
            "application/geo+json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/QualityIndicator"
                }
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Metrics have been created."
          },
          "400": {
            "description": "Bad request. Metrics is already exsisted."
          },
          "500": {
            "description": "Unexpected error"
          }
        }
      }
    },
    "/series/{seriesId}/datasets/{datasetId}/productInformation/qualityInformation/qualityIndicators/{metricName}": {
      "put": {
        "description": "Update a metric.",
        "operationId": "Metric",
        "tags": [
          "Metric"
        ],
        "parameters": [
          {
            "name": "seriesId",
            "in": "path",
            "x-value": "{eo:parentIdentifier}",
            "required": true,
            "description": "Series identifier.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "datasetId",
            "in": "path",
            "x-value": "{geo:uid}",
            "required": true,
            "description": "Dataset identifier.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "metricName",
            "in": "path",
            "required": true,
            "description": "name of metric.",
            "schema": {
              "type": "string",
              "enum": [
                "degradedDataPercentageMetric",
                "degradedAncillaryDataPercentageMetric",
                "formatCorrectnessMetric",
                "generalQualityMetric",
                "geometricQualityMetric",
                "radiometricQualityMetric",
                "sensorQualityMetric",
                "feasibilityControlMetric",
                "deliveryControlMetric",
                "ordinaryControlMetric"
              ]
            }
          }
        ],
        "requestBody": {
          "description": "update a metric of a dataset.",
          "required": true,
          "content": {
            "application/geo+json": {
              "schema": {
                "$ref": "#/components/schemas/QualityIndicator"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Metric has been updated."
          },
          "400": {
            "description": "Bad request. Metric not yet exsisted."
          },
          "500": {
            "description": "Unexpected error"
          }
        }
      },
      "delete": {
        "description": "Delete a metric of a dataset.",
        "operationId": "DeleteMetric",
        "tags": [
          "Metric"
        ],
        "parameters": [
          {
            "name": "seriesId",
            "in": "path",
            "x-value": "{eo:parentIdentifier}",
            "required": true,
            "description": "Series identifier.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "datasetId",
            "in": "path",
            "x-value": "{geo:uid}",
            "required": true,
            "description": "Dataset identifier.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "metricName",
            "in": "path",
            "required": true,
            "description": "name of metric.",
            "schema": {
              "type": "string",
              "enum": [
                "degradedDataPercentageMetric",
                "degradedAncillaryDataPercentageMetric",
                "formatCorrectnessMetric",
                "generalQualityMetric",
                "geometricQualityMetric",
                "radiometricQualityMetric",
                "sensorQualityMetric",
                "feasibilityControlMetric",
                "deliveryControlMetric",
                "ordinaryControlMetric"
              ]
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Metric has been deleted."
          },
          "500": {
            "description": "Unexpected error"
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "Point": {
        "title": "Point",
        "type": "object",
        "properties": {
          "coordinates": {
            "title": "coordinates",
            "description": "One position (longitude, latitude)",
            "type": "array",
            "minItems": 2,
            "maxItems": 2,
            "items": {
              "type": "number"
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "Point"
            ]
          }
        },
        "required": [
          "coordinates",
          "type"
        ],
        "additionalProperties": false
      },
      "MultiPoint": {
        "title": "point",
        "type": "object",
        "properties": {
          "coordinates": {
            "title": "coordinates",
            "description": "Array of positions",
            "type": "array",
            "minItems": 1,
            "items": {
              "description": "One position",
              "type": "array",
              "minItems": 2,
              "maxItems": 2,
              "items": {
                "type": "number"
              }
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "MultiPoint"
            ]
          }
        },
        "required": [
          "coordinates",
          "type"
        ],
        "additionalProperties": false
      },
      "LineString": {
        "title": "LineString",
        "type": "object",
        "properties": {
          "coordinates": {
            "title": "coordinates",
            "description": "Array of positions",
            "type": "array",
            "minItems": 2,
            "items": {
              "description": "One position",
              "type": "array",
              "minItems": 2,
              "maxItems": 2,
              "items": {
                "type": "number"
              }
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "LineString"
            ]
          }
        },
        "required": [
          "coordinates",
          "type"
        ],
        "additionalProperties": false
      },
      "MultiLineString": {
        "title": "MultiLineString",
        "type": "object",
        "properties": {
          "coordinates": {
            "title": "coordinates",
            "description": "Array of linestring",
            "type": "array",
            "minItems": 1,
            "items": {
              "description": "Linestring, i.e. array of positions",
              "type": "array",
              "minItems": 2,
              "items": {
                "description": "Position (longitude, lattitude)",
                "type": "array",
                "minItems": 2,
                "maxItems": 2,
                "items": {
                  "type": "number"
                }
              }
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "MultiLineString"
            ]
          }
        },
        "required": [
          "coordinates",
          "type"
        ],
        "additionalProperties": false
      },
      "Polygon": {
        "title": "Polygon",
        "type": "object",
        "properties": {
          "coordinates": {
            "title": "coordinates",
            "description": "Array of linestrings",
            "type": "array",
            "minItems": 1,
            "items": {
              "description": "Linear ring, i.e. linestring or array of positions",
              "type": "array",
              "minItems": 1,
              "items": {
                "description": "One position",
                "type": "array",
                "minItems": 2,
                "maxItems": 2,
                "items": {
                  "type": "number"
                }
              }
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "Polygon"
            ]
          }
        },
        "required": [
          "coordinates",
          "type"
        ],
        "additionalProperties": false
      },
      "MultiPolygon": {
        "title": "MultiPolygon",
        "type": "object",
        "properties": {
          "coordinates": {
            "title": "coordinates",
            "description": "Array of Polygons",
            "type": "array",
            "minItems": 1,
            "items": {
              "description": "Array of linestrings",
              "type": "array",
              "minItems": 1,
              "items": {
                "description": "Linear ring, i.e. linestring or array of positions",
                "type": "array",
                "items": {
                  "description": "One position",
                  "type": "array",
                  "minItems": 2,
                  "maxItems": 2,
                  "items": {
                    "type": "number"
                  }
                }
              }
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "MultiPolygon"
            ]
          }
        },
        "required": [
          "coordinates",
          "type"
        ],
        "additionalProperties": false
      },
      "Geometry": {
        "title": "Geometry",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/Point"
          },
          {
            "$ref": "#/components/schemas/MultiPoint"
          },
          {
            "$ref": "#/components/schemas/LineString"
          },
          {
            "$ref": "#/components/schemas/MultiLineString"
          },
          {
            "$ref": "#/components/schemas/Polygon"
          },
          {
            "$ref": "#/components/schemas/MultiPolygon"
          }
        ]
      },
      "Links": {
        "title": "Links",
        "description": "OGC 14-055r2",
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "Links"
            ]
          },
          "profiles": {
            "description": "OGC 14-055r2",
            "type": "array",
            "minItems": 1,
            "items": {
              "$ref": "#/components/schemas/Link"
            }
          },
          "alternates": {
            "description": "OGC 14-055r2",
            "type": "array",
            "minItems": 1,
            "items": {
              "$ref": "#/components/schemas/Link"
            }
          },
          "via": {
            "description": "OGC 14-055r2",
            "type": "array",
            "minItems": 1,
            "items": {
              "$ref": "#/components/schemas/Link"
            }
          },
          "related": {
            "description": "OGC 14-055r2",
            "type": "array",
            "minItems": 1,
            "items": {
              "$ref": "#/components/schemas/Link"
            }
          },
          "first": {
            "type": "array",
            "minItems": 1,
            "items": {
              "$ref": "#/components/schemas/Link"
            }
          },
          "last": {
            "type": "array",
            "minItems": 1,
            "items": {
              "$ref": "#/components/schemas/Link"
            }
          },
          "previous": {
            "type": "array",
            "minItems": 1,
            "items": {
              "$ref": "#/components/schemas/Link"
            }
          },
          "next": {
            "type": "array",
            "minItems": 1,
            "items": {
              "$ref": "#/components/schemas/Link"
            }
          },
          "search": {
            "type": "array",
            "minItems": 1,
            "items": {
              "$ref": "#/components/schemas/Link"
            }
          },
          "describedby": {
            "type": "array",
            "minItems": 1,
            "items": {
              "$ref": "#/components/schemas/Link"
            }
          }
        },
        "additionalProperties": {
          "type": "array",
          "minItems": 1,
          "items": {
            "$ref": "#/components/schemas/Link"
          }
        }
      },
      "Properties": {
        "title": "Properties",
        "type": "object",
        "allOf": [
          {
            "type": "object",
            "properties": {
              "lang": {
                "description": "OGC 14-055r2",
                "type": "string",
                "minLength": 2
              },
              "subtitle": {
                "description": "OGC 14-055r2",
                "type": "string"
              },
              "creator": {
                "description": "OGC 14-055r2",
                "type": "string"
              },
              "links": {
                "$ref": "#/components/schemas/Links"
              },
              "generator": {
                "$ref": "#/components/schemas/Agent"
              }
            },
            "required": [
              "lang",
              "links"
            ]
          },
          {
            "$ref": "#/components/schemas/CommonProperties"
          }
        ]
      },
      "Feature": {
        "description": "GeoJSON Feature",
        "type": "object",
        "properties": {
          "type": {
            "title": "type",
            "type": "string",
            "enum": [
              "Feature"
            ]
          },
          "id": {
            "type": "string",
            "format": "uri"
          },
          "geometry": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/Geometry"
              }
            ],
            "nullable": true
          },
          "bbox": {
            "type": "array",
            "minItems": 4,
            "maxItems": 4,
            "items": {
              "type": "number"
            }
          },
          "properties": {
            "$ref": "#/components/schemas/Properties_"
          }
        },
        "required": [
          "type",
          "id",
          "properties"
        ]
      },
      "Link": {
        "description": "OGC 14-055r2",
        "type": "object",
        "properties": {
          "href": {
            "type": "string",
            "format": "uri"
          },
          "type": {
            "description": "MIME type",
            "type": "string"
          },
          "title": {
            "type": "string"
          },
          "length": {
            "type": "integer",
            "minimum": 0,
            "exclusiveMinimum": true
          },
          "lang": {
            "description": "RFC-3066",
            "type": "string"
          }
        },
        "required": [
          "href"
        ]
      },
      "FeatureCollection": {
        "description": "GeoJSON FeatureCollection",
        "type": "object",
        "allOf": [
          {
            "type": "object",
            "properties": {
              "@context": {
                "type": "string"
              },
              "type": {
                "description": "OGC 14-055r2",
                "type": "string",
                "enum": [
                  "FeatureCollection"
                ]
              },
              "id": {
                "description": "OGC 14-055r2",
                "type": "string",
                "format": "uri"
              },
              "bbox": {
                "type": "array",
                "items": {
                  "type": "object"
                }
              },
              "properties": {
                "$ref": "#/components/schemas/Properties"
              },
              "features": {
                "type": "array",
                "minItems": 0,
                "items": {
                  "$ref": "#/components/schemas/Feature"
                }
              },
              "exceptions": {
                "type": "array",
                "minItems": 1,
                "items": {
                  "$ref": "#/components/schemas/Exception"
                }
              }
            },
            "required": [
              "type",
              "id",
              "features"
            ]
          },
          {
            "$ref": "#/components/schemas/ControlInformation"
          }
        ]
      },
      "Offering": {
        "title": "Offering",
        "description": "Offering as defined in OGC 14-055r2",
        "type": "object",
        "properties": {
          "code": {
            "type": "string",
            "format": "uri"
          },
          "operations": {
            "type": "array",
            "items": {
              "type": "object"
            }
          },
          "contents": {
            "type": "array",
            "items": {
              "type": "object"
            }
          },
          "styles": {
            "type": "array",
            "items": {
              "type": "object"
            }
          }
        },
        "required": [
          "code"
        ]
      },
      "Queries": {
        "description": "Object with queries grouped by \"role\".  See also http://www.opensearch.org/Specifications/OpenSearch/1.1#OpenSearch_Query_element",
        "type": "object",
        "properties": {
          "@context": {
            "type": "object"
          },
          "type": {
            "type": "string",
            "enum": [
              "Queries"
            ]
          }
        },
        "additionalProperties": {
          "description": "Additional role values as per http://www.opensearch.org/Specifications/OpenSearch/1.1#Role_values.",
          "type": "array",
          "minItems": 1,
          "items": {
            "$ref": "#/components/schemas/Query"
          }
        }
      },
      "Query": {
        "description": "OpenSearch Query element as defined at http://www.opensearch.org/Specifications/OpenSearch/1.1#OpenSearch_Query_element.",
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "Query"
            ]
          },
          "title": {
            "type": "string"
          },
          "totalResults": {
            "type": "integer",
            "minimum": 0
          },
          "searchTerms": {
            "type": "string"
          },
          "count": {
            "type": "integer",
            "minimum": 0
          },
          "startIndex": {
            "type": "integer",
            "minimum": 0
          },
          "startPage": {
            "type": "integer",
            "minimum": 0
          },
          "language": {
            "type": "string"
          },
          "inputEncoding": {
            "type": "string"
          },
          "outputEncoding": {
            "type": "string"
          }
        },
        "additionalProperties": true
      },
      "ControlInformation": {
        "type": "object",
        "properties": {
          "totalResults": {
            "type": "integer",
            "minimum": 0
          },
          "startIndex": {
            "type": "integer",
            "minimum": 0
          },
          "itemsPerPage": {
            "type": "integer",
            "minimum": 0
          },
          "queries": {
            "$ref": "#/components/schemas/Queries"
          }
        },
        "required": [
          "totalResults",
          "startIndex",
          "itemsPerPage"
        ]
      },
      "Agent": {
        "description": "RFC4287 3.2 and OGC 14-055r2 7.1.1.7, 7.1.8",
        "type": "object",
        "minProperties": 1,
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "Agent",
              "Person",
              "Organization"
            ]
          },
          "name": {
            "type": "string"
          },
          "email": {
            "type": "string",
            "format": "email"
          },
          "uri": {
            "type": "string",
            "format": "uri"
          },
          "title": {
            "description": "OGC 14-055r2 7.1.8",
            "type": "string"
          },
          "version": {
            "description": "OGC 14-055r2 7.1.8",
            "type": "string"
          }
        }
      },
      "Category": {
        "description": "OGC 14-055r2 7.1.1.15",
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "Category"
            ]
          },
          "scheme": {
            "type": "string",
            "format": "uri"
          },
          "term": {
            "type": "string"
          },
          "label": {
            "type": "string"
          }
        },
        "required": [
          "term"
        ],
        "additionalProperties": false
      },
      "Properties_": {
        "title": "Properties",
        "type": "object",
        "allOf": [
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "Properties"
                ]
              },
              "status": {
                "type": "string",
                "enum": [
                  "ARCHIVED",
                  "PLANNED",
                  "ACQUIRED",
                  "CANCELLED",
                  "FAILED",
                  "POTENTIAL",
                  "REJECTED",
                  "QUALITYDEGRADED"
                ]
              },
              "acquisitionInformation": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/AcquisitionInformation"
                }
              },
              "productInformation": {
                "$ref": "#/components/schemas/ProductInformation"
              },
              "links": {
                "$ref": "#/components/schemas/Links"
              },
              "offerings": {
                "description": "OGC 14-055r2",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/Offering"
                }
              }
            },
            "required": [
              "status",
              "acquisitionInformation",
              "links"
            ]
          },
          {
            "$ref": "#/components/schemas/DataIdentification"
          }
        ]
      },
      "ProductInformation": {
        "type": "object",
        "allOf": [
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "ProductInformation"
                ]
              },
              "productType": {
                "type": "string"
              },
              "size": {
                "type": "integer"
              },
              "productVersion": {
                "type": "string"
              },
              "statusSubType": {
                "type": "string",
                "enum": [
                  "ON-LINE",
                  "OFF-LINE"
                ]
              },
              "qualityInformation": {
                "$ref": "#/components/schemas/QualityInformation"
              },
              "statusDetail": {
                "type": "string"
              },
              "availabilityTime": {
                "type": "string",
                "format": "date-time"
              },
              "timeliness": {
                "type": "string"
              },
              "productGroupId": {
                "type": "string"
              },
              "archivingCenter": {
                "type": "string"
              },
              "referenceSystemIdentifier": {
                "type": "string"
              },
              "archivingDate": {
                "type": "string",
                "format": "date-time"
              }
            },
            "required": [
              "availabilityTime"
            ]
          },
          {
            "$ref": "#/components/schemas/ProcessingInformation"
          },
          {
            "$ref": "#/components/schemas/CoverageDescription"
          }
        ]
      },
      "ProcessingInformation": {
        "description": "Subset of ProductInformation",
        "type": "object",
        "properties": {
          "processingLevel": {
            "type": "string",
            "enum": [
              "1A",
              "1B",
              "1C",
              "2",
              "3"
            ]
          },
          "processorName": {
            "type": "string"
          },
          "processorVersion": {
            "type": "string"
          },
          "processingCenter": {
            "description": "Codelist",
            "type": "string"
          },
          "processingDate": {
            "type": "string",
            "format": "date-time"
          },
          "processingMode": {
            "description": "Codelist",
            "type": "string"
          },
          "compositeType": {
            "type": "string"
          },
          "format": {
            "type": "string"
          },
          "productContentsType": {
            "type": "string"
          },
          "processingMethod": {
            "type": "string"
          },
          "processingMethodVersion": {
            "type": "string"
          }
        }
      },
      "QualityInformationDef": {
        "type": "object",
        "properties": {
          "qualityStatus": {
            "type": "string",
            "enum": [
              "NOMINAL",
              "DEGRADED"
            ]
          },
          "qualityDegradation": {
            "description": "Percentage",
            "type": "number"
          },
          "qualityDegradationTag": {
            "type": "string"
          },
          "qualityDegradationQuotationMode": {
            "type": "string",
            "enum": [
              "AUTOMATIC",
              "MANUAL"
            ]
          }
        }
      },
      "QualityInformation": {
        "description": "Extended QualityInformation defined in OGC 17-003",
        "type": "object",
        "allOf": [
          {
            "$ref": "#/components/schemas/QualityInformationDef"
          },
          {
            "type": "object",
            "properties": {
              "qualityIndicators": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/QualityIndicator"
                }
              }
            }
          }
        ]
      },
      "DeliveryControlInformation": {
        "description": "Results of QCMMS check 2",
        "type": "object",
        "allOf": [
          {
            "type": "object",
            "properties": {
              "status": {
                "type": "string",
                "enum": [
                  "WAITING",
                  "IN_PROGRESS",
                  "FINISHED",
                  "NOT_AVAILABLE"
                ]
              },
              "complete": {
                "type": "boolean"
              },
              "date": {
                "type": "string",
                "format": "date-time"
              },
              "filename": {
                "type": "string"
              }
            }
          },
          {
            "$ref": "#/components/schemas/QualityMeasurement"
          }
        ]
      },
      "OrdinaryControlInformation": {
        "description": "Results of QCMMS check 3",
        "type": "object",
        "allOf": [
          {
            "type": "object"
          },
          {
            "$ref": "#/components/schemas/QualityMeasurement"
          }
        ]
      },
      "DetailedControlInformation": {
        "description": "Results of QCMMS check 4",
        "type": "object",
        "allOf": [
          {
            "type": "object",
            "properties": {
              "attribute3": {
                "type": "string"
              }
            }
          },
          {
            "$ref": "#/components/schemas/QualityMeasurement"
          }
        ]
      },
      "FeasibilityControlInformation": {
        "description": "Results of QCMMS check 1",
        "type": "object",
        "allOf": [
          {
            "$ref": "#/components/schemas/QualityMeasurement"
          },
          {
            "type": "object",
            "properties": {
              "searchDate": {
                "type": "string",
                "format": "date-time"
              },
              "searchDateUpdate": {
                "type": "string",
                "format": "date-time"
              }
            }
          }
        ]
      },
      "QualityIndicator": {
        "type": "object",
        "allOf": [
          {
            "$ref": "#/components/schemas/QualityMeasurement"
          },
          {
            "$ref": "#/components/schemas/FeasibilityControlInformation"
          },
          {
            "$ref": "#/components/schemas/DeliveryControlInformation"
          },
          {
            "$ref": "#/components/schemas/OrdinaryControlInformation"
          },
          {
            "$ref": "#/components/schemas/DetailedControlInformation"
          }
        ]
      },
      "QualityMeasurement": {
        "description": "dqv:QualityMeasurement",
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "QualityMeasurement"
            ]
          },
          "isMeasurementOf": {
            "description": "dqv:isMeasurementOf",
            "type": "string",
            "format": "uri",
            "enum": [
              "http://qcmms.esa.int/quality-indicators/#degradedAncillaryDataPercentageMetric",
              "http://qcmms.esa.int/quality-indicators/#sensorQualityMetric",
              "http://qcmms.esa.int/quality-indicators/#radiometricQualityMetric",
              "http://qcmms.esa.int/quality-indicators/#degradedDataPercentageMetric",
              "http://qcmms.esa.int/quality-indicators/#geometricQualityMetric",
              "http://qcmms.esa.int/quality-indicators/#generalQualityMetric",
              "http://qcmms.esa.int/quality-indicators/#formatCorrectnessMetric",
              "http://qcmms.esa.int/quality-indicators/#feasibilityControlMetric",
              "http://qcmms.esa.int/quality-indicators/#deliveryControlMetric",
              "http://qcmms.esa.int/quality-indicators/#ordinaryControlMetric",
              "http://qcmms.esa.int/quality-indicators/#detailedControlMetric"
            ]
          },
          "value": {
            "description": "dqv:value"
          },
          "generatedAtTime": {
            "description": "prov:generatedAtTime",
            "type": "string",
            "format": "date-time"
          }
        },
        "required": [
          "isMeasurementOf",
          "value"
        ]
      },
      "CoverageDescription": {
        "description": "Subset of ProductInformation",
        "type": "object",
        "properties": {
          "cloudCover": {
            "type": "number"
          },
          "snowCover": {
            "type": "number"
          }
        }
      },
      "DataIdentification": {
        "description": "Subset of Properties",
        "type": "object",
        "properties": {
          "parentIdentifier": {
            "type": "string"
          },
          "doi": {
            "type": "string"
          },
          "title": {
            "type": "string"
          },
          "identifier": {
            "type": "string"
          },
          "date": {
            "type": "string"
          },
          "updated": {
            "type": "string",
            "pattern": "^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}(\\.[0-9]+)?(Z|[\\+\\-][0-9]{2}:[0-9]{2})$",
            "format": "date-time"
          },
          "additionalAttributes": {
            "type": "object",
            "minProperties": 1
          }
        },
        "required": [
          "title",
          "identifier",
          "date",
          "updated"
        ]
      },
      "OrbitParameters": {
        "description": "Subset of AcquisitionParameters",
        "type": "object",
        "properties": {
          "orbitDirection": {
            "type": "string",
            "enum": [
              "ASCENDING",
              "DESCENDING"
            ]
          },
          "lastOrbitDirection": {
            "type": "string",
            "enum": [
              "ASCENDING",
              "DESCENDING"
            ]
          },
          "orbitDuration": {
            "type": "integer"
          },
          "ascendingNodeDate": {
            "type": "string",
            "format": "date-time"
          },
          "ascendingNodeLongitude": {
            "type": "number"
          },
          "orbitNumber": {
            "type": "integer",
            "minimum": 0
          },
          "lastOrbitNumber": {
            "type": "number"
          }
        }
      },
      "WavelengthInformation": {
        "type": "object",
        "minProperties": 1,
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "WavelengthInformation"
            ]
          },
          "discreteWavelengths": {
            "type": "array",
            "minItems": 1,
            "items": {
              "type": "number",
              "minimum": 0,
              "exclusiveMinimum": true
            }
          },
          "endWavelength": {
            "type": "number",
            "minimum": 0,
            "exclusiveMinimum": true
          },
          "spectralRange": {
            "type": "string",
            "enum": [
              "INFRARED",
              "NIR",
              "SWIR",
              "MWIR",
              "LWIR",
              "FIR",
              "UV",
              "VISIBLE",
              "MICROWAVE",
              "OTHER"
            ]
          },
          "startWavelength": {
            "type": "number",
            "minimum": 0,
            "exclusiveMinimum": true
          },
          "wavelengthResolution": {
            "type": "number"
          }
        },
        "additionalProperties": false
      },
      "VerticalSpatialDomain": {
        "description": "Subset of AcquisitionParameters",
        "type": "object",
        "properties": {
          "highestLocation": {
            "type": "string"
          },
          "lowestLocation": {
            "type": "string"
          },
          "locationUnit": {
            "type": "string",
            "enum": [
              "bar",
              "m"
            ]
          }
        }
      },
      "TemporalInformation": {
        "description": "Subset of AcquisitionParameters",
        "type": "object",
        "properties": {
          "beginningDateTime": {
            "type": "string",
            "format": "date-time"
          },
          "endingDateTime": {
            "type": "string",
            "format": "date-time"
          }
        },
        "required": [
          "beginningDateTime",
          "endingDateTime"
        ]
      },
      "AcquisitionAngles": {
        "type": "object",
        "properties": {
          "illuminationAzimuthAngle": {
            "type": "number"
          },
          "illuminationZenithAngle": {
            "type": "number"
          },
          "illuminationElevationAngle": {
            "type": "number"
          },
          "incidenceAngle": {
            "type": "number"
          },
          "minimumIncidenceAngle": {
            "type": "number"
          },
          "maximumIncidenceAngle": {
            "type": "number"
          },
          "incidenceAngleVariation": {
            "type": "number"
          },
          "acrossTrackIncidenceAngle": {
            "type": "number"
          },
          "alongTrackIncidenceAngle": {
            "type": "number"
          },
          "instrumentAzimuthAngle": {
            "type": "number"
          },
          "instrumentZenithAngle": {
            "type": "number"
          },
          "instrumentElevationAngle": {
            "type": "number"
          },
          "pitch": {
            "type": "number"
          },
          "roll": {
            "type": "number"
          },
          "yaw": {
            "type": "number"
          }
        },
        "additionalProperties": false
      },
      "Platform": {
        "type": "object",
        "minProperties": 1,
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "Platform"
            ]
          },
          "id": {
            "type": "string",
            "format": "uri"
          },
          "platformShortName": {
            "type": "string"
          },
          "platformSerialIdentifier": {
            "type": "string"
          },
          "orbitType": {
            "type": "string",
            "enum": [
              "GEO",
              "LEO"
            ]
          }
        },
        "required": [
          "platformShortName"
        ],
        "additionalProperties": false
      },
      "Instrument": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "Instrument"
            ]
          },
          "id": {
            "type": "string",
            "format": "uri"
          },
          "sensorType": {
            "type": "string",
            "enum": [
              "OPTICAL",
              "RADAR",
              "ATMOSPHERIC",
              "ALTIMETRIC",
              "LIMB"
            ]
          },
          "instrumentShortName": {
            "type": "string"
          },
          "description": {
            "type": "string"
          }
        },
        "required": [
          "instrumentShortName"
        ],
        "additionalProperties": false
      },
      "InstrumentParameters": {
        "type": "object",
        "minProperties": 1,
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "InstrumentParameters"
            ]
          },
          "operationalMode": {
            "type": "string"
          },
          "swathIdentifier": {
            "type": "string"
          },
          "polarisationMode": {
            "description": "Sar",
            "type": "string",
            "enum": [
              "S",
              "D",
              "T",
              "Q",
              "UNDEFINED"
            ]
          },
          "polarisationChannels": {
            "description": "Sar",
            "type": "string"
          },
          "resolution": {
            "type": "number"
          },
          "verticalResolution": {
            "description": "Atm, Lmb",
            "type": "number"
          },
          "waveLengths": {
            "type": "array",
            "minItems": 1,
            "items": {
              "$ref": "#/components/schemas/WavelengthInformation"
            }
          },
          "measurementType": {
            "type": "string",
            "enum": [
              "ABSORPTION",
              "EMISSION"
            ]
          },
          "dopplerFrequency": {
            "description": "Sar",
            "type": "number",
            "minimum": 0,
            "exclusiveMinimum": true
          },
          "samplingRates": {
            "description": "Alt",
            "type": "array",
            "items": {
              "type": "number",
              "minimum": 0,
              "exclusiveMinimum": true
            }
          }
        },
        "additionalProperties": false
      },
      "AcquisitionParameters": {
        "type": "object",
        "allOf": [
          {
            "type": "object",
            "properties": {
              "acquisitionType": {
                "type": "string",
                "enum": [
                  "NOMINAL",
                  "CALIBRATION",
                  "OTHER"
                ]
              },
              "acquisitionSubType": {
                "type": "string"
              },
              "startTimeFromAscendingNode": {
                "type": "integer",
                "minimum": 0
              },
              "completionTimeFromAscendingNode": {
                "type": "integer",
                "minimum": 0
              },
              "relativeOrbitNumber": {
                "type": "integer"
              },
              "wrsLongitude": {
                "type": "string"
              },
              "wrsLatitude": {
                "type": "string"
              },
              "tileId": {
                "type": "string"
              },
              "groundTrackUncertainty": {
                "type": "number"
              },
              "cycleNumber": {
                "type": "integer",
                "minimum": 0
              },
              "antennaLookDirection": {
                "type": "string",
                "enum": [
                  "LEFT",
                  "RIGHT"
                ]
              },
              "acquisitionStation": {
                "type": "string"
              },
              "acquisitionAngles": {
                "$ref": "#/components/schemas/AcquisitionAngles"
              }
            },
            "required": [
              "acquisitionType"
            ]
          },
          {
            "$ref": "#/components/schemas/TemporalInformation"
          },
          {
            "$ref": "#/components/schemas/VerticalSpatialDomain"
          },
          {
            "$ref": "#/components/schemas/OrbitParameters"
          }
        ]
      },
      "AcquisitionInformation": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "AcquisitionInformation"
            ]
          },
          "platform": {
            "$ref": "#/components/schemas/Platform"
          },
          "instrument": {
            "$ref": "#/components/schemas/Instrument"
          },
          "instrumentParameters": {
            "$ref": "#/components/schemas/InstrumentParameters"
          },
          "acquisitionParameters": {
            "$ref": "#/components/schemas/AcquisitionParameters"
          }
        }
      },
      "CommonProperties": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "Properties"
            ]
          },
          "title": {
            "description": "OGC 14-055r2",
            "type": "string"
          },
          "updated": {
            "description": "OGC 14-055r2",
            "type": "string",
            "format": "date-time"
          },
          "date": {
            "description": "OGC 14-055r2",
            "type": "string"
          },
          "publisher": {
            "description": "OGC 14-055r2",
            "type": "string"
          },
          "rights": {
            "description": "OGC 14-055r2",
            "type": "string"
          },
          "authors": {
            "description": "OGC 14-055r2",
            "type": "array",
            "minItems": 1,
            "items": {
              "$ref": "#/components/schemas/Agent"
            }
          },
          "categories": {
            "description": "OGC 14-055r2",
            "type": "array",
            "minItems": 1,
            "items": {
              "$ref": "#/components/schemas/Category"
            }
          }
        },
        "required": [
          "title",
          "updated"
        ]
      },
      "Exception": {
        "description": "OGC 06-121r9",
        "type": "object",
        "properties": {
          "exceptionCode": {
            "description": "Represents ows:exceptionCode",
            "type": "string",
            "format": "uri"
          },
          "exceptionText": {
            "description": "Represents ows:exceptionText",
            "type": "string"
          },
          "locator": {
            "description": "Represents ows:locator.",
            "type": "string"
          }
        },
        "required": [
          "exceptionCode"
        ],
        "additionalProperties": false
      },
      "ExceptionReport": {
        "description": "OGC 06-121r9",
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "ExceptionReport"
            ]
          },
          "exceptions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Exception"
            }
          }
        }
      }
    }
  }
}